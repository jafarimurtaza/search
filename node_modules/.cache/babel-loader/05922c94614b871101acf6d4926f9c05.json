{"ast":null,"code":"'use strict';\n\nfunction clone(value) {\n  if (typeof value === 'object' && value !== null) {\n    return _merge(Array.isArray(value) ? [] : {}, value);\n  }\n\n  return value;\n}\n\nfunction isObjectOrArrayOrFunction(value) {\n  return typeof value === 'function' || Array.isArray(value) || Object.prototype.toString.call(value) === '[object Object]';\n}\n\nfunction _merge(target, source) {\n  if (target === source) {\n    return target;\n  }\n\n  for (var key in source) {\n    if (!Object.prototype.hasOwnProperty.call(source, key)) {\n      continue;\n    }\n\n    var sourceVal = source[key];\n    var targetVal = target[key];\n\n    if (typeof targetVal !== 'undefined' && typeof sourceVal === 'undefined') {\n      continue;\n    }\n\n    if (isObjectOrArrayOrFunction(targetVal) && isObjectOrArrayOrFunction(sourceVal)) {\n      target[key] = _merge(targetVal, sourceVal);\n    } else {\n      target[key] = clone(sourceVal);\n    }\n  }\n\n  return target;\n}\n/**\n * This method is like Object.assign, but recursively merges own and inherited\n * enumerable keyed properties of source objects into the destination object.\n *\n * NOTE: this behaves like lodash/merge, but:\n * - does mutate functions if they are a source\n * - treats non-plain objects as plain\n * - does not work for circular objects\n * - treats sparse arrays as sparse\n * - does not convert Array-like objects (Arguments, NodeLists, etc.) to arrays\n *\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n */\n\n\nfunction merge(target) {\n  if (!isObjectOrArrayOrFunction(target)) {\n    target = {};\n  }\n\n  for (var i = 1, l = arguments.length; i < l; i++) {\n    var source = arguments[i];\n\n    if (isObjectOrArrayOrFunction(source)) {\n      _merge(target, source);\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = merge;","map":{"version":3,"sources":["C:/Users/Murtaza Jafari/Desktop/product-search/product/searcbox/node_modules/algoliasearch-helper/src/functions/merge.js"],"names":["clone","value","_merge","Array","isArray","isObjectOrArrayOrFunction","Object","prototype","toString","call","target","source","key","hasOwnProperty","sourceVal","targetVal","merge","i","l","arguments","length","module","exports"],"mappings":"AAAA;;AAEA,SAASA,KAAT,CAAeC,KAAf,EAAsB;AACpB,MAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD;AAC/C,WAAOC,MAAM,CAACC,KAAK,CAACC,OAAN,CAAcH,KAAd,IAAuB,EAAvB,GAA4B,EAA7B,EAAiCA,KAAjC,CAAb;AACD;;AACD,SAAOA,KAAP;AACD;;AAED,SAASI,yBAAT,CAAmCJ,KAAnC,EAA0C;AACxC,SACE,OAAOA,KAAP,KAAiB,UAAjB,IACAE,KAAK,CAACC,OAAN,CAAcH,KAAd,CADA,IAEAK,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BR,KAA/B,MAA0C,iBAH5C;AAKD;;AAED,SAASC,MAAT,CAAgBQ,MAAhB,EAAwBC,MAAxB,EAAgC;AAC9B,MAAID,MAAM,KAAKC,MAAf,EAAuB;AACrB,WAAOD,MAAP;AACD;;AAED,OAAK,IAAIE,GAAT,IAAgBD,MAAhB,EAAwB;AACtB,QAAI,CAACL,MAAM,CAACC,SAAP,CAAiBM,cAAjB,CAAgCJ,IAAhC,CAAqCE,MAArC,EAA6CC,GAA7C,CAAL,EAAwD;AACtD;AACD;;AAED,QAAIE,SAAS,GAAGH,MAAM,CAACC,GAAD,CAAtB;AACA,QAAIG,SAAS,GAAGL,MAAM,CAACE,GAAD,CAAtB;;AAEA,QAAI,OAAOG,SAAP,KAAqB,WAArB,IAAoC,OAAOD,SAAP,KAAqB,WAA7D,EAA0E;AACxE;AACD;;AAED,QAAIT,yBAAyB,CAACU,SAAD,CAAzB,IAAwCV,yBAAyB,CAACS,SAAD,CAArE,EAAkF;AAChFJ,MAAAA,MAAM,CAACE,GAAD,CAAN,GAAcV,MAAM,CAACa,SAAD,EAAYD,SAAZ,CAApB;AACD,KAFD,MAEO;AACLJ,MAAAA,MAAM,CAACE,GAAD,CAAN,GAAcZ,KAAK,CAACc,SAAD,CAAnB;AACD;AACF;;AACD,SAAOJ,MAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASM,KAAT,CAAeN,MAAf,EAAuB;AACrB,MAAI,CAACL,yBAAyB,CAACK,MAAD,CAA9B,EAAwC;AACtCA,IAAAA,MAAM,GAAG,EAAT;AACD;;AAED,OAAK,IAAIO,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCH,CAAC,GAAGC,CAA1C,EAA6CD,CAAC,EAA9C,EAAkD;AAChD,QAAIN,MAAM,GAAGQ,SAAS,CAACF,CAAD,CAAtB;;AAEA,QAAIZ,yBAAyB,CAACM,MAAD,CAA7B,EAAuC;AACrCT,MAAAA,MAAM,CAACQ,MAAD,EAASC,MAAT,CAAN;AACD;AACF;;AACD,SAAOD,MAAP;AACD;;AAEDW,MAAM,CAACC,OAAP,GAAiBN,KAAjB","sourcesContent":["'use strict';\n\nfunction clone(value) {\n  if (typeof value === 'object' && value !== null) {\n    return _merge(Array.isArray(value) ? [] : {}, value);\n  }\n  return value;\n}\n\nfunction isObjectOrArrayOrFunction(value) {\n  return (\n    typeof value === 'function' ||\n    Array.isArray(value) ||\n    Object.prototype.toString.call(value) === '[object Object]'\n  );\n}\n\nfunction _merge(target, source) {\n  if (target === source) {\n    return target;\n  }\n\n  for (var key in source) {\n    if (!Object.prototype.hasOwnProperty.call(source, key)) {\n      continue;\n    }\n\n    var sourceVal = source[key];\n    var targetVal = target[key];\n\n    if (typeof targetVal !== 'undefined' && typeof sourceVal === 'undefined') {\n      continue;\n    }\n\n    if (isObjectOrArrayOrFunction(targetVal) && isObjectOrArrayOrFunction(sourceVal)) {\n      target[key] = _merge(targetVal, sourceVal);\n    } else {\n      target[key] = clone(sourceVal);\n    }\n  }\n  return target;\n}\n\n/**\n * This method is like Object.assign, but recursively merges own and inherited\n * enumerable keyed properties of source objects into the destination object.\n *\n * NOTE: this behaves like lodash/merge, but:\n * - does mutate functions if they are a source\n * - treats non-plain objects as plain\n * - does not work for circular objects\n * - treats sparse arrays as sparse\n * - does not convert Array-like objects (Arguments, NodeLists, etc.) to arrays\n *\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n */\n\nfunction merge(target) {\n  if (!isObjectOrArrayOrFunction(target)) {\n    target = {};\n  }\n\n  for (var i = 1, l = arguments.length; i < l; i++) {\n    var source = arguments[i];\n\n    if (isObjectOrArrayOrFunction(source)) {\n      _merge(target, source);\n    }\n  }\n  return target;\n}\n\nmodule.exports = merge;\n"]},"metadata":{},"sourceType":"script"}