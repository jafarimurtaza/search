{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport PropTypes from 'prop-types';\nimport { find } from '../core/utils';\nimport createConnector from '../core/createConnector';\nimport { cleanUpValue, getIndexId, getResults, refineValue, getCurrentRefinementValue } from '../core/indexUtils';\n\nfunction getId(props) {\n  return props.attribute;\n}\n\nvar namespace = 'toggle';\nvar falsyStrings = ['0', 'false', 'null', 'undefined'];\n\nfunction getCurrentRefinement(props, searchState, context) {\n  var currentRefinement = getCurrentRefinementValue(props, searchState, context, \"\".concat(namespace, \".\").concat(getId(props)), false);\n\n  if (falsyStrings.indexOf(currentRefinement) !== -1) {\n    return false;\n  }\n\n  return Boolean(currentRefinement);\n}\n\nfunction _refine(props, searchState, nextRefinement, context) {\n  var id = getId(props);\n\n  var nextValue = _defineProperty({}, id, nextRefinement ? nextRefinement : false);\n\n  var resetPage = true;\n  return refineValue(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction _cleanUp(props, searchState, context) {\n  return cleanUpValue(searchState, context, \"\".concat(namespace, \".\").concat(getId(props)));\n}\n/**\n * connectToggleRefinement connector provides the logic to build a widget that will\n * provides an on/off filtering feature based on an attribute value.\n * @name connectToggleRefinement\n * @kind connector\n * @requirements To use this widget, you'll need an attribute to toggle on.\n *\n * You can't toggle on null or not-null values. If you want to address this particular use-case you'll need to compute an\n * extra boolean attribute saying if the value exists or not. See this [thread](https://discourse.algolia.com/t/how-to-create-a-toggle-for-the-absence-of-a-string-attribute/2460) for more details.\n *\n * @propType {string} attribute - Name of the attribute on which to apply the `value` refinement. Required when `value` is present.\n * @propType {string} label - Label for the toggle.\n * @propType {string} value - Value of the refinement to apply on `attribute`.\n * @propType {boolean} [defaultRefinement=false] - Default searchState of the widget. Should the toggle be checked by default?\n * @providedPropType {boolean} currentRefinement - `true` when the refinement is applied, `false` otherwise\n * @providedPropType {object} count - an object that contains the count for `checked` and `unchecked` state\n * @providedPropType {function} refine - a function to toggle a refinement\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n */\n\n\nexport default createConnector({\n  displayName: 'AlgoliaToggle',\n  propTypes: {\n    label: PropTypes.string.isRequired,\n    attribute: PropTypes.string.isRequired,\n    value: PropTypes.any.isRequired,\n    filter: PropTypes.func,\n    defaultRefinement: PropTypes.bool\n  },\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var attribute = props.attribute,\n        value = props.value;\n    var results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    var currentRefinement = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    var allFacetValues = results && results.getFacetByName(attribute) ? results.getFacetValues(attribute) : null;\n    var facetValue = // Use null to always be consistent with type of the value\n    // count: number | null\n    allFacetValues && allFacetValues.length ? find(allFacetValues, function (item) {\n      return item.name === value.toString();\n    }) : null;\n    var facetValueCount = facetValue && facetValue.count;\n    var allFacetValuesCount = // Use null to always be consistent with type of the value\n    // count: number | null\n    allFacetValues && allFacetValues.length ? allFacetValues.reduce(function (acc, item) {\n      return acc + item.count;\n    }, 0) : null;\n    var canRefine = currentRefinement ? allFacetValuesCount !== null && allFacetValuesCount > 0 : facetValueCount !== null && facetValueCount > 0;\n    var count = {\n      checked: allFacetValuesCount,\n      unchecked: facetValueCount\n    };\n    return {\n      currentRefinement: currentRefinement,\n      canRefine: canRefine,\n      count: count\n    };\n  },\n  refine: function refine(props, searchState, nextRefinement) {\n    return _refine(props, searchState, nextRefinement, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return _cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  getSearchParameters: function getSearchParameters(searchParameters, props, searchState) {\n    var attribute = props.attribute,\n        value = props.value,\n        filter = props.filter;\n    var checked = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    var nextSearchParameters = searchParameters.addDisjunctiveFacet(attribute);\n\n    if (checked) {\n      nextSearchParameters = nextSearchParameters.addDisjunctiveFacetRefinement(attribute, value);\n\n      if (filter) {\n        nextSearchParameters = filter(nextSearchParameters);\n      }\n    }\n\n    return nextSearchParameters;\n  },\n  getMetadata: function getMetadata(props, searchState) {\n    var id = getId(props);\n    var checked = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    var items = [];\n    var index = getIndexId({\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n\n    if (checked) {\n      items.push({\n        label: props.label,\n        currentRefinement: checked,\n        attribute: props.attribute,\n        value: function value(nextState) {\n          return _refine(props, nextState, false, {\n            ais: props.contextValue,\n            multiIndexContext: props.indexContextValue\n          });\n        }\n      });\n    }\n\n    return {\n      id: id,\n      index: index,\n      items: items\n    };\n  }\n});","map":{"version":3,"sources":["C:/Users/Murtaza Jafari/Desktop/product-search/product/searcbox/node_modules/react-instantsearch-core/dist/es/connectors/connectToggleRefinement.js"],"names":["_defineProperty","PropTypes","find","createConnector","cleanUpValue","getIndexId","getResults","refineValue","getCurrentRefinementValue","getId","props","attribute","namespace","falsyStrings","getCurrentRefinement","searchState","context","currentRefinement","concat","indexOf","Boolean","_refine","nextRefinement","id","nextValue","resetPage","_cleanUp","displayName","propTypes","label","string","isRequired","value","any","filter","func","defaultRefinement","bool","getProvidedProps","searchResults","results","ais","contextValue","multiIndexContext","indexContextValue","allFacetValues","getFacetByName","getFacetValues","facetValue","length","item","name","toString","facetValueCount","count","allFacetValuesCount","reduce","acc","canRefine","checked","unchecked","refine","cleanUp","getSearchParameters","searchParameters","nextSearchParameters","addDisjunctiveFacet","addDisjunctiveFacetRefinement","getMetadata","items","index","push","nextState"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport PropTypes from 'prop-types';\nimport { find } from '../core/utils';\nimport createConnector from '../core/createConnector';\nimport { cleanUpValue, getIndexId, getResults, refineValue, getCurrentRefinementValue } from '../core/indexUtils';\n\nfunction getId(props) {\n  return props.attribute;\n}\n\nvar namespace = 'toggle';\nvar falsyStrings = ['0', 'false', 'null', 'undefined'];\n\nfunction getCurrentRefinement(props, searchState, context) {\n  var currentRefinement = getCurrentRefinementValue(props, searchState, context, \"\".concat(namespace, \".\").concat(getId(props)), false);\n\n  if (falsyStrings.indexOf(currentRefinement) !== -1) {\n    return false;\n  }\n\n  return Boolean(currentRefinement);\n}\n\nfunction _refine(props, searchState, nextRefinement, context) {\n  var id = getId(props);\n\n  var nextValue = _defineProperty({}, id, nextRefinement ? nextRefinement : false);\n\n  var resetPage = true;\n  return refineValue(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction _cleanUp(props, searchState, context) {\n  return cleanUpValue(searchState, context, \"\".concat(namespace, \".\").concat(getId(props)));\n}\n/**\n * connectToggleRefinement connector provides the logic to build a widget that will\n * provides an on/off filtering feature based on an attribute value.\n * @name connectToggleRefinement\n * @kind connector\n * @requirements To use this widget, you'll need an attribute to toggle on.\n *\n * You can't toggle on null or not-null values. If you want to address this particular use-case you'll need to compute an\n * extra boolean attribute saying if the value exists or not. See this [thread](https://discourse.algolia.com/t/how-to-create-a-toggle-for-the-absence-of-a-string-attribute/2460) for more details.\n *\n * @propType {string} attribute - Name of the attribute on which to apply the `value` refinement. Required when `value` is present.\n * @propType {string} label - Label for the toggle.\n * @propType {string} value - Value of the refinement to apply on `attribute`.\n * @propType {boolean} [defaultRefinement=false] - Default searchState of the widget. Should the toggle be checked by default?\n * @providedPropType {boolean} currentRefinement - `true` when the refinement is applied, `false` otherwise\n * @providedPropType {object} count - an object that contains the count for `checked` and `unchecked` state\n * @providedPropType {function} refine - a function to toggle a refinement\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n */\n\n\nexport default createConnector({\n  displayName: 'AlgoliaToggle',\n  propTypes: {\n    label: PropTypes.string.isRequired,\n    attribute: PropTypes.string.isRequired,\n    value: PropTypes.any.isRequired,\n    filter: PropTypes.func,\n    defaultRefinement: PropTypes.bool\n  },\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var attribute = props.attribute,\n        value = props.value;\n    var results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    var currentRefinement = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    var allFacetValues = results && results.getFacetByName(attribute) ? results.getFacetValues(attribute) : null;\n    var facetValue = // Use null to always be consistent with type of the value\n    // count: number | null\n    allFacetValues && allFacetValues.length ? find(allFacetValues, function (item) {\n      return item.name === value.toString();\n    }) : null;\n    var facetValueCount = facetValue && facetValue.count;\n    var allFacetValuesCount = // Use null to always be consistent with type of the value\n    // count: number | null\n    allFacetValues && allFacetValues.length ? allFacetValues.reduce(function (acc, item) {\n      return acc + item.count;\n    }, 0) : null;\n    var canRefine = currentRefinement ? allFacetValuesCount !== null && allFacetValuesCount > 0 : facetValueCount !== null && facetValueCount > 0;\n    var count = {\n      checked: allFacetValuesCount,\n      unchecked: facetValueCount\n    };\n    return {\n      currentRefinement: currentRefinement,\n      canRefine: canRefine,\n      count: count\n    };\n  },\n  refine: function refine(props, searchState, nextRefinement) {\n    return _refine(props, searchState, nextRefinement, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return _cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  getSearchParameters: function getSearchParameters(searchParameters, props, searchState) {\n    var attribute = props.attribute,\n        value = props.value,\n        filter = props.filter;\n    var checked = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    var nextSearchParameters = searchParameters.addDisjunctiveFacet(attribute);\n\n    if (checked) {\n      nextSearchParameters = nextSearchParameters.addDisjunctiveFacetRefinement(attribute, value);\n\n      if (filter) {\n        nextSearchParameters = filter(nextSearchParameters);\n      }\n    }\n\n    return nextSearchParameters;\n  },\n  getMetadata: function getMetadata(props, searchState) {\n    var id = getId(props);\n    var checked = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    var items = [];\n    var index = getIndexId({\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n\n    if (checked) {\n      items.push({\n        label: props.label,\n        currentRefinement: checked,\n        attribute: props.attribute,\n        value: function value(nextState) {\n          return _refine(props, nextState, false, {\n            ais: props.contextValue,\n            multiIndexContext: props.indexContextValue\n          });\n        }\n      });\n    }\n\n    return {\n      id: id,\n      index: index,\n      items: items\n    };\n  }\n});"]},"metadata":{},"sourceType":"module"}