{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread\";\nimport algoliasearchHelper from 'algoliasearch-helper';\nimport createWidgetsManager from './createWidgetsManager';\nimport createStore from './createStore';\nimport { HIGHLIGHT_TAGS } from './highlight';\nimport { hasMultipleIndices } from './indexUtils';\nimport { version as ReactVersion } from 'react';\nimport version from './version';\n\nfunction addAlgoliaAgents(searchClient) {\n  if (typeof searchClient.addAlgoliaAgent === 'function') {\n    searchClient.addAlgoliaAgent(\"react (\".concat(ReactVersion, \")\"));\n    searchClient.addAlgoliaAgent(\"react-instantsearch (\".concat(version, \")\"));\n  }\n}\n\nvar isMultiIndexContext = function isMultiIndexContext(widget) {\n  return hasMultipleIndices({\n    ais: widget.props.contextValue,\n    multiIndexContext: widget.props.indexContextValue\n  });\n};\n\nvar isTargetedIndexEqualIndex = function isTargetedIndexEqualIndex(widget, indexId) {\n  return widget.props.indexContextValue.targetedIndex === indexId;\n}; // Relying on the `indexId` is a bit brittle to detect the `Index` widget.\n// Since it's a class we could rely on `instanceof` or similar. We never\n// had an issue though. Works for now.\n\n\nvar isIndexWidget = function isIndexWidget(widget) {\n  return Boolean(widget.props.indexId);\n};\n\nvar isIndexWidgetEqualIndex = function isIndexWidgetEqualIndex(widget, indexId) {\n  return widget.props.indexId === indexId;\n};\n\nvar sortIndexWidgetsFirst = function sortIndexWidgetsFirst(firstWidget, secondWidget) {\n  var isFirstWidgetIndex = isIndexWidget(firstWidget);\n  var isSecondWidgetIndex = isIndexWidget(secondWidget);\n\n  if (isFirstWidgetIndex && !isSecondWidgetIndex) {\n    return -1;\n  }\n\n  if (!isFirstWidgetIndex && isSecondWidgetIndex) {\n    return 1;\n  }\n\n  return 0;\n}; // This function is copied from the algoliasearch v4 API Client. If modified,\n// consider updating it also in `serializeQueryParameters` from `@algolia/transporter`.\n\n\nfunction serializeQueryParameters(parameters) {\n  var isObjectOrArray = function isObjectOrArray(value) {\n    return Object.prototype.toString.call(value) === '[object Object]' || Object.prototype.toString.call(value) === '[object Array]';\n  };\n\n  var encode = function encode(format) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var i = 0;\n    return format.replace(/%s/g, function () {\n      return encodeURIComponent(args[i++]);\n    });\n  };\n\n  return Object.keys(parameters).map(function (key) {\n    return encode('%s=%s', key, isObjectOrArray(parameters[key]) ? JSON.stringify(parameters[key]) : parameters[key]);\n  }).join('&');\n}\n/**\n * Creates a new instance of the InstantSearchManager which controls the widgets and\n * trigger the search when the widgets are updated.\n * @param {string} indexName - the main index name\n * @param {object} initialState - initial widget state\n * @param {object} SearchParameters - optional additional parameters to send to the algolia API\n * @param {number} stalledSearchDelay - time (in ms) after the search is stalled\n * @return {InstantSearchManager} a new instance of InstantSearchManager\n */\n\n\nexport default function createInstantSearchManager(_ref) {\n  var indexName = _ref.indexName,\n      _ref$initialState = _ref.initialState,\n      initialState = _ref$initialState === void 0 ? {} : _ref$initialState,\n      searchClient = _ref.searchClient,\n      resultsState = _ref.resultsState,\n      stalledSearchDelay = _ref.stalledSearchDelay;\n  var helper = algoliasearchHelper(searchClient, indexName, _objectSpread({}, HIGHLIGHT_TAGS));\n  addAlgoliaAgents(searchClient);\n  helper.on('search', handleNewSearch).on('result', handleSearchSuccess({\n    indexId: indexName\n  })).on('error', handleSearchError);\n  var skip = false;\n  var stalledSearchTimer = null;\n  var initialSearchParameters = helper.state;\n  var widgetsManager = createWidgetsManager(onWidgetsUpdate);\n  hydrateSearchClient(searchClient, resultsState);\n  var store = createStore({\n    widgets: initialState,\n    metadata: hydrateMetadata(resultsState),\n    results: hydrateResultsState(resultsState),\n    error: null,\n    searching: false,\n    isSearchStalled: true,\n    searchingForFacetValues: false\n  });\n\n  function skipSearch() {\n    skip = true;\n  }\n\n  function updateClient(client) {\n    addAlgoliaAgents(client);\n    helper.setClient(client);\n    search();\n  }\n\n  function clearCache() {\n    helper.clearCache();\n    search();\n  }\n\n  function getMetadata(state) {\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getMetadata);\n    }).map(function (widget) {\n      return widget.getMetadata(state);\n    });\n  }\n\n  function getSearchParameters() {\n    var sharedParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      return !isMultiIndexContext(widget) && !isIndexWidget(widget);\n    }).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, initialSearchParameters);\n    var mainParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexEqualMainIndex = isMultiIndexContext(widget) && isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexEqualMainIndex = isIndexWidget(widget) && isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexEqualMainIndex || subIndexEqualMainIndex;\n    }) // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, sharedParameters);\n    var derivedIndices = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexNotEqualMainIndex = isMultiIndexContext(widget) && !isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexNotEqualMainIndex = isIndexWidget(widget) && !isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexNotEqualMainIndex || subIndexNotEqualMainIndex;\n    }) // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (indices, widget) {\n      var indexId = isMultiIndexContext(widget) ? widget.props.indexContextValue.targetedIndex : widget.props.indexId;\n      var widgets = indices[indexId] || [];\n      return _objectSpread({}, indices, _defineProperty({}, indexId, widgets.concat(widget)));\n    }, {});\n    var derivedParameters = Object.keys(derivedIndices).map(function (indexId) {\n      return {\n        parameters: derivedIndices[indexId].reduce(function (res, widget) {\n          return widget.getSearchParameters(res);\n        }, sharedParameters),\n        indexId: indexId\n      };\n    });\n    return {\n      mainParameters: mainParameters,\n      derivedParameters: derivedParameters\n    };\n  }\n\n  function search() {\n    if (!skip) {\n      var _getSearchParameters = getSearchParameters(helper.state),\n          mainParameters = _getSearchParameters.mainParameters,\n          derivedParameters = _getSearchParameters.derivedParameters; // We have to call `slice` because the method `detach` on the derived\n      // helpers mutates the value `derivedHelpers`. The `forEach` loop does\n      // not iterate on each value and we're not able to correctly clear the\n      // previous derived helpers (memory leak + useless requests).\n\n\n      helper.derivedHelpers.slice().forEach(function (derivedHelper) {\n        // Since we detach the derived helpers on **every** new search they\n        // won't receive intermediate results in case of a stalled search.\n        // Only the last result is dispatched by the derived helper because\n        // they are not detached yet:\n        //\n        // - a -> main helper receives results\n        // - ap -> main helper receives results\n        // - app -> main helper + derived helpers receive results\n        //\n        // The quick fix is to avoid to detach them on search but only once they\n        // received the results. But it means that in case of a stalled search\n        // all the derived helpers not detached yet register a new search inside\n        // the helper. The number grows fast in case of a bad network and it's\n        // not deterministic.\n        derivedHelper.detach();\n      });\n      derivedParameters.forEach(function (_ref2) {\n        var indexId = _ref2.indexId,\n            parameters = _ref2.parameters;\n        var derivedHelper = helper.derive(function () {\n          return parameters;\n        });\n        derivedHelper.on('result', handleSearchSuccess({\n          indexId: indexId\n        })).on('error', handleSearchError);\n      });\n      helper.setState(mainParameters);\n      helper.search();\n    }\n  }\n\n  function handleSearchSuccess(_ref3) {\n    var indexId = _ref3.indexId;\n    return function (event) {\n      var state = store.getState();\n      var isDerivedHelpersEmpty = !helper.derivedHelpers.length;\n      var results = state.results ? state.results : {}; // Switching from mono index to multi index and vice versa must reset the\n      // results to an empty object, otherwise we keep reference of stalled and\n      // unused results.\n\n      results = !isDerivedHelpersEmpty && results.getFacetByName ? {} : results;\n\n      if (!isDerivedHelpersEmpty) {\n        results = _objectSpread({}, results, _defineProperty({}, indexId, event.results));\n      } else {\n        results = event.results;\n      }\n\n      var currentState = store.getState();\n      var nextIsSearchStalled = currentState.isSearchStalled;\n\n      if (!helper.hasPendingRequests()) {\n        clearTimeout(stalledSearchTimer);\n        stalledSearchTimer = null;\n        nextIsSearchStalled = false;\n      }\n\n      var resultsFacetValues = currentState.resultsFacetValues,\n          partialState = _objectWithoutProperties(currentState, [\"resultsFacetValues\"]);\n\n      store.setState(_objectSpread({}, partialState, {\n        results: results,\n        isSearchStalled: nextIsSearchStalled,\n        searching: false,\n        error: null\n      }));\n    };\n  }\n\n  function handleSearchError(_ref4) {\n    var error = _ref4.error;\n    var currentState = store.getState();\n    var nextIsSearchStalled = currentState.isSearchStalled;\n\n    if (!helper.hasPendingRequests()) {\n      clearTimeout(stalledSearchTimer);\n      nextIsSearchStalled = false;\n    }\n\n    var resultsFacetValues = currentState.resultsFacetValues,\n        partialState = _objectWithoutProperties(currentState, [\"resultsFacetValues\"]);\n\n    store.setState(_objectSpread({}, partialState, {\n      isSearchStalled: nextIsSearchStalled,\n      error: error,\n      searching: false\n    }));\n  }\n\n  function handleNewSearch() {\n    if (!stalledSearchTimer) {\n      stalledSearchTimer = setTimeout(function () {\n        var _store$getState = store.getState(),\n            resultsFacetValues = _store$getState.resultsFacetValues,\n            partialState = _objectWithoutProperties(_store$getState, [\"resultsFacetValues\"]);\n\n        store.setState(_objectSpread({}, partialState, {\n          isSearchStalled: true\n        }));\n      }, stalledSearchDelay);\n    }\n  }\n\n  function hydrateSearchClient(client, results) {\n    if (!results) {\n      return;\n    } // Disable cache hydration on:\n    // - Algoliasearch API Client < v4 with cache disabled\n    // - Third party clients (detected by the `addAlgoliaAgent` function missing)\n\n\n    if ((!client.transporter || client._cacheHydrated) && (!client._useCache || typeof client.addAlgoliaAgent !== 'function')) {\n      return;\n    } // Algoliasearch API Client >= v4\n    // To hydrate the client we need to populate the cache with the data from\n    // the server (done in `hydrateSearchClientWithMultiIndexRequest` or\n    // `hydrateSearchClientWithSingleIndexRequest`). But since there is no way\n    // for us to compute the key the same way as `algoliasearch-client` we need\n    // to populate it on a custom key and override the `search` method to\n    // search on it first.\n\n\n    if (client.transporter && !client._cacheHydrated) {\n      client._cacheHydrated = true;\n      var baseMethod = client.search;\n\n      client.search = function (requests) {\n        for (var _len2 = arguments.length, methodArgs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          methodArgs[_key2 - 1] = arguments[_key2];\n        }\n\n        var requestsWithSerializedParams = requests.map(function (request) {\n          return _objectSpread({}, request, {\n            params: serializeQueryParameters(request.params)\n          });\n        });\n        return client.transporter.responsesCache.get({\n          method: 'search',\n          args: [requestsWithSerializedParams].concat(methodArgs)\n        }, function () {\n          return baseMethod.apply(void 0, [requests].concat(methodArgs));\n        });\n      };\n    }\n\n    if (Array.isArray(results.results)) {\n      hydrateSearchClientWithMultiIndexRequest(client, results.results);\n      return;\n    }\n\n    hydrateSearchClientWithSingleIndexRequest(client, results);\n  }\n\n  function hydrateSearchClientWithMultiIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults.map(function (request) {\n            return {\n              indexName: request.index,\n              params: request.params\n            };\n          }));\n        }, [])]\n      }, {\n        results: results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults);\n        }, [])\n      });\n      return;\n    } // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n\n\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        }));\n      }, [])\n    }));\n    client.cache = _objectSpread({}, client.cache, _defineProperty({}, key, JSON.stringify({\n      results: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults);\n      }, [])\n    })));\n  }\n\n  function hydrateSearchClientWithSingleIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        })]\n      }, {\n        results: results.rawResults\n      });\n      return;\n    } // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n\n\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.rawResults.map(function (request) {\n        return {\n          indexName: request.index,\n          params: request.params\n        };\n      })\n    }));\n    client.cache = _objectSpread({}, client.cache, _defineProperty({}, key, JSON.stringify({\n      results: results.rawResults\n    })));\n  }\n\n  function hydrateResultsState(results) {\n    if (!results) {\n      return null;\n    }\n\n    if (Array.isArray(results.results)) {\n      return results.results.reduce(function (acc, result) {\n        return _objectSpread({}, acc, _defineProperty({}, result._internalIndexId, new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(result.state), result.rawResults)));\n      }, {});\n    }\n\n    return new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(results.state), results.rawResults);\n  } // Called whenever a widget has been rendered with new props.\n\n\n  function onWidgetsUpdate() {\n    var metadata = getMetadata(store.getState().widgets);\n    store.setState(_objectSpread({}, store.getState(), {\n      metadata: metadata,\n      searching: true\n    })); // Since the `getSearchParameters` method of widgets also depends on props,\n    // the result search parameters might have changed.\n\n    search();\n  }\n\n  function transitionState(nextSearchState) {\n    var searchState = store.getState().widgets;\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.transitionState);\n    }).reduce(function (res, widget) {\n      return widget.transitionState(searchState, res);\n    }, nextSearchState);\n  }\n\n  function onExternalStateUpdate(nextSearchState) {\n    var metadata = getMetadata(nextSearchState);\n    store.setState(_objectSpread({}, store.getState(), {\n      widgets: nextSearchState,\n      metadata: metadata,\n      searching: true\n    }));\n    search();\n  }\n\n  function onSearchForFacetValues(_ref5) {\n    var facetName = _ref5.facetName,\n        query = _ref5.query,\n        _ref5$maxFacetHits = _ref5.maxFacetHits,\n        maxFacetHits = _ref5$maxFacetHits === void 0 ? 10 : _ref5$maxFacetHits; // The values 1, 100 are the min / max values that the engine accepts.\n    // see: https://www.algolia.com/doc/api-reference/api-parameters/maxFacetHits\n\n    var maxFacetHitsWithinRange = Math.max(1, Math.min(maxFacetHits, 100));\n    store.setState(_objectSpread({}, store.getState(), {\n      searchingForFacetValues: true\n    }));\n    helper.searchForFacetValues(facetName, query, maxFacetHitsWithinRange).then(function (content) {\n      var _objectSpread7;\n\n      store.setState(_objectSpread({}, store.getState(), {\n        error: null,\n        searchingForFacetValues: false,\n        resultsFacetValues: _objectSpread({}, store.getState().resultsFacetValues, (_objectSpread7 = {}, _defineProperty(_objectSpread7, facetName, content.facetHits), _defineProperty(_objectSpread7, \"query\", query), _objectSpread7))\n      }));\n    }, function (error) {\n      store.setState(_objectSpread({}, store.getState(), {\n        searchingForFacetValues: false,\n        error: error\n      }));\n    }).catch(function (error) {\n      // Since setState is synchronous, any error that occurs in the render of a\n      // component will be swallowed by this promise.\n      // This is a trick to make the error show up correctly in the console.\n      // See http://stackoverflow.com/a/30741722/969302\n      setTimeout(function () {\n        throw error;\n      });\n    });\n  }\n\n  function updateIndex(newIndex) {\n    initialSearchParameters = initialSearchParameters.setIndex(newIndex); // No need to trigger a new search here as the widgets will also update and trigger it if needed.\n  }\n\n  function getWidgetsIds() {\n    return store.getState().metadata.reduce(function (res, meta) {\n      return typeof meta.id !== 'undefined' ? res.concat(meta.id) : res;\n    }, []);\n  }\n\n  return {\n    store: store,\n    widgetsManager: widgetsManager,\n    getWidgetsIds: getWidgetsIds,\n    getSearchParameters: getSearchParameters,\n    onSearchForFacetValues: onSearchForFacetValues,\n    onExternalStateUpdate: onExternalStateUpdate,\n    transitionState: transitionState,\n    updateClient: updateClient,\n    updateIndex: updateIndex,\n    clearCache: clearCache,\n    skipSearch: skipSearch\n  };\n}\n\nfunction hydrateMetadata(resultsState) {\n  if (!resultsState) {\n    return [];\n  } // add a value noop, which gets replaced once the widgets are mounted\n\n\n  return resultsState.metadata.map(function (datum) {\n    return _objectSpread({\n      value: function value() {}\n    }, datum, {\n      items: datum.items && datum.items.map(function (item) {\n        return _objectSpread({\n          value: function value() {}\n        }, item, {\n          items: item.items && item.items.map(function (nestedItem) {\n            return _objectSpread({\n              value: function value() {}\n            }, nestedItem);\n          })\n        });\n      })\n    });\n  });\n}","map":{"version":3,"sources":["C:/Users/Murtaza Jafari/Desktop/product-search/product/searcbox/node_modules/react-instantsearch-core/dist/es/core/createInstantSearchManager.js"],"names":["_objectWithoutProperties","_defineProperty","_objectSpread","algoliasearchHelper","createWidgetsManager","createStore","HIGHLIGHT_TAGS","hasMultipleIndices","version","ReactVersion","addAlgoliaAgents","searchClient","addAlgoliaAgent","concat","isMultiIndexContext","widget","ais","props","contextValue","multiIndexContext","indexContextValue","isTargetedIndexEqualIndex","indexId","targetedIndex","isIndexWidget","Boolean","isIndexWidgetEqualIndex","sortIndexWidgetsFirst","firstWidget","secondWidget","isFirstWidgetIndex","isSecondWidgetIndex","serializeQueryParameters","parameters","isObjectOrArray","value","Object","prototype","toString","call","encode","format","_len","arguments","length","args","Array","_key","i","replace","encodeURIComponent","keys","map","key","JSON","stringify","join","createInstantSearchManager","_ref","indexName","_ref$initialState","initialState","resultsState","stalledSearchDelay","helper","on","handleNewSearch","handleSearchSuccess","handleSearchError","skip","stalledSearchTimer","initialSearchParameters","state","widgetsManager","onWidgetsUpdate","hydrateSearchClient","store","widgets","metadata","hydrateMetadata","results","hydrateResultsState","error","searching","isSearchStalled","searchingForFacetValues","skipSearch","updateClient","client","setClient","search","clearCache","getMetadata","getWidgets","filter","getSearchParameters","sharedParameters","reduce","res","mainParameters","targetedIndexEqualMainIndex","subIndexEqualMainIndex","sort","derivedIndices","targetedIndexNotEqualMainIndex","subIndexNotEqualMainIndex","indices","derivedParameters","_getSearchParameters","derivedHelpers","slice","forEach","derivedHelper","detach","_ref2","derive","setState","_ref3","event","getState","isDerivedHelpersEmpty","getFacetByName","currentState","nextIsSearchStalled","hasPendingRequests","clearTimeout","resultsFacetValues","partialState","_ref4","setTimeout","_store$getState","transporter","_cacheHydrated","_useCache","baseMethod","requests","_len2","methodArgs","_key2","requestsWithSerializedParams","request","params","responsesCache","get","method","apply","isArray","hydrateSearchClientWithMultiIndexRequest","hydrateSearchClientWithSingleIndexRequest","set","acc","result","rawResults","index","cache","_internalIndexId","SearchResults","SearchParameters","transitionState","nextSearchState","searchState","onExternalStateUpdate","onSearchForFacetValues","_ref5","facetName","query","_ref5$maxFacetHits","maxFacetHits","maxFacetHitsWithinRange","Math","max","min","searchForFacetValues","then","content","_objectSpread7","facetHits","catch","updateIndex","newIndex","setIndex","getWidgetsIds","meta","id","datum","items","item","nestedItem"],"mappings":"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","sourcesContent":["import _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread\";\nimport algoliasearchHelper from 'algoliasearch-helper';\nimport createWidgetsManager from './createWidgetsManager';\nimport createStore from './createStore';\nimport { HIGHLIGHT_TAGS } from './highlight';\nimport { hasMultipleIndices } from './indexUtils';\nimport { version as ReactVersion } from 'react';\nimport version from './version';\n\nfunction addAlgoliaAgents(searchClient) {\n  if (typeof searchClient.addAlgoliaAgent === 'function') {\n    searchClient.addAlgoliaAgent(\"react (\".concat(ReactVersion, \")\"));\n    searchClient.addAlgoliaAgent(\"react-instantsearch (\".concat(version, \")\"));\n  }\n}\n\nvar isMultiIndexContext = function isMultiIndexContext(widget) {\n  return hasMultipleIndices({\n    ais: widget.props.contextValue,\n    multiIndexContext: widget.props.indexContextValue\n  });\n};\n\nvar isTargetedIndexEqualIndex = function isTargetedIndexEqualIndex(widget, indexId) {\n  return widget.props.indexContextValue.targetedIndex === indexId;\n}; // Relying on the `indexId` is a bit brittle to detect the `Index` widget.\n// Since it's a class we could rely on `instanceof` or similar. We never\n// had an issue though. Works for now.\n\n\nvar isIndexWidget = function isIndexWidget(widget) {\n  return Boolean(widget.props.indexId);\n};\n\nvar isIndexWidgetEqualIndex = function isIndexWidgetEqualIndex(widget, indexId) {\n  return widget.props.indexId === indexId;\n};\n\nvar sortIndexWidgetsFirst = function sortIndexWidgetsFirst(firstWidget, secondWidget) {\n  var isFirstWidgetIndex = isIndexWidget(firstWidget);\n  var isSecondWidgetIndex = isIndexWidget(secondWidget);\n\n  if (isFirstWidgetIndex && !isSecondWidgetIndex) {\n    return -1;\n  }\n\n  if (!isFirstWidgetIndex && isSecondWidgetIndex) {\n    return 1;\n  }\n\n  return 0;\n}; // This function is copied from the algoliasearch v4 API Client. If modified,\n// consider updating it also in `serializeQueryParameters` from `@algolia/transporter`.\n\n\nfunction serializeQueryParameters(parameters) {\n  var isObjectOrArray = function isObjectOrArray(value) {\n    return Object.prototype.toString.call(value) === '[object Object]' || Object.prototype.toString.call(value) === '[object Array]';\n  };\n\n  var encode = function encode(format) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var i = 0;\n    return format.replace(/%s/g, function () {\n      return encodeURIComponent(args[i++]);\n    });\n  };\n\n  return Object.keys(parameters).map(function (key) {\n    return encode('%s=%s', key, isObjectOrArray(parameters[key]) ? JSON.stringify(parameters[key]) : parameters[key]);\n  }).join('&');\n}\n/**\n * Creates a new instance of the InstantSearchManager which controls the widgets and\n * trigger the search when the widgets are updated.\n * @param {string} indexName - the main index name\n * @param {object} initialState - initial widget state\n * @param {object} SearchParameters - optional additional parameters to send to the algolia API\n * @param {number} stalledSearchDelay - time (in ms) after the search is stalled\n * @return {InstantSearchManager} a new instance of InstantSearchManager\n */\n\n\nexport default function createInstantSearchManager(_ref) {\n  var indexName = _ref.indexName,\n      _ref$initialState = _ref.initialState,\n      initialState = _ref$initialState === void 0 ? {} : _ref$initialState,\n      searchClient = _ref.searchClient,\n      resultsState = _ref.resultsState,\n      stalledSearchDelay = _ref.stalledSearchDelay;\n  var helper = algoliasearchHelper(searchClient, indexName, _objectSpread({}, HIGHLIGHT_TAGS));\n  addAlgoliaAgents(searchClient);\n  helper.on('search', handleNewSearch).on('result', handleSearchSuccess({\n    indexId: indexName\n  })).on('error', handleSearchError);\n  var skip = false;\n  var stalledSearchTimer = null;\n  var initialSearchParameters = helper.state;\n  var widgetsManager = createWidgetsManager(onWidgetsUpdate);\n  hydrateSearchClient(searchClient, resultsState);\n  var store = createStore({\n    widgets: initialState,\n    metadata: hydrateMetadata(resultsState),\n    results: hydrateResultsState(resultsState),\n    error: null,\n    searching: false,\n    isSearchStalled: true,\n    searchingForFacetValues: false\n  });\n\n  function skipSearch() {\n    skip = true;\n  }\n\n  function updateClient(client) {\n    addAlgoliaAgents(client);\n    helper.setClient(client);\n    search();\n  }\n\n  function clearCache() {\n    helper.clearCache();\n    search();\n  }\n\n  function getMetadata(state) {\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getMetadata);\n    }).map(function (widget) {\n      return widget.getMetadata(state);\n    });\n  }\n\n  function getSearchParameters() {\n    var sharedParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      return !isMultiIndexContext(widget) && !isIndexWidget(widget);\n    }).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, initialSearchParameters);\n    var mainParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexEqualMainIndex = isMultiIndexContext(widget) && isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexEqualMainIndex = isIndexWidget(widget) && isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexEqualMainIndex || subIndexEqualMainIndex;\n    }) // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, sharedParameters);\n    var derivedIndices = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexNotEqualMainIndex = isMultiIndexContext(widget) && !isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexNotEqualMainIndex = isIndexWidget(widget) && !isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexNotEqualMainIndex || subIndexNotEqualMainIndex;\n    }) // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (indices, widget) {\n      var indexId = isMultiIndexContext(widget) ? widget.props.indexContextValue.targetedIndex : widget.props.indexId;\n      var widgets = indices[indexId] || [];\n      return _objectSpread({}, indices, _defineProperty({}, indexId, widgets.concat(widget)));\n    }, {});\n    var derivedParameters = Object.keys(derivedIndices).map(function (indexId) {\n      return {\n        parameters: derivedIndices[indexId].reduce(function (res, widget) {\n          return widget.getSearchParameters(res);\n        }, sharedParameters),\n        indexId: indexId\n      };\n    });\n    return {\n      mainParameters: mainParameters,\n      derivedParameters: derivedParameters\n    };\n  }\n\n  function search() {\n    if (!skip) {\n      var _getSearchParameters = getSearchParameters(helper.state),\n          mainParameters = _getSearchParameters.mainParameters,\n          derivedParameters = _getSearchParameters.derivedParameters; // We have to call `slice` because the method `detach` on the derived\n      // helpers mutates the value `derivedHelpers`. The `forEach` loop does\n      // not iterate on each value and we're not able to correctly clear the\n      // previous derived helpers (memory leak + useless requests).\n\n\n      helper.derivedHelpers.slice().forEach(function (derivedHelper) {\n        // Since we detach the derived helpers on **every** new search they\n        // won't receive intermediate results in case of a stalled search.\n        // Only the last result is dispatched by the derived helper because\n        // they are not detached yet:\n        //\n        // - a -> main helper receives results\n        // - ap -> main helper receives results\n        // - app -> main helper + derived helpers receive results\n        //\n        // The quick fix is to avoid to detach them on search but only once they\n        // received the results. But it means that in case of a stalled search\n        // all the derived helpers not detached yet register a new search inside\n        // the helper. The number grows fast in case of a bad network and it's\n        // not deterministic.\n        derivedHelper.detach();\n      });\n      derivedParameters.forEach(function (_ref2) {\n        var indexId = _ref2.indexId,\n            parameters = _ref2.parameters;\n        var derivedHelper = helper.derive(function () {\n          return parameters;\n        });\n        derivedHelper.on('result', handleSearchSuccess({\n          indexId: indexId\n        })).on('error', handleSearchError);\n      });\n      helper.setState(mainParameters);\n      helper.search();\n    }\n  }\n\n  function handleSearchSuccess(_ref3) {\n    var indexId = _ref3.indexId;\n    return function (event) {\n      var state = store.getState();\n      var isDerivedHelpersEmpty = !helper.derivedHelpers.length;\n      var results = state.results ? state.results : {}; // Switching from mono index to multi index and vice versa must reset the\n      // results to an empty object, otherwise we keep reference of stalled and\n      // unused results.\n\n      results = !isDerivedHelpersEmpty && results.getFacetByName ? {} : results;\n\n      if (!isDerivedHelpersEmpty) {\n        results = _objectSpread({}, results, _defineProperty({}, indexId, event.results));\n      } else {\n        results = event.results;\n      }\n\n      var currentState = store.getState();\n      var nextIsSearchStalled = currentState.isSearchStalled;\n\n      if (!helper.hasPendingRequests()) {\n        clearTimeout(stalledSearchTimer);\n        stalledSearchTimer = null;\n        nextIsSearchStalled = false;\n      }\n\n      var resultsFacetValues = currentState.resultsFacetValues,\n          partialState = _objectWithoutProperties(currentState, [\"resultsFacetValues\"]);\n\n      store.setState(_objectSpread({}, partialState, {\n        results: results,\n        isSearchStalled: nextIsSearchStalled,\n        searching: false,\n        error: null\n      }));\n    };\n  }\n\n  function handleSearchError(_ref4) {\n    var error = _ref4.error;\n    var currentState = store.getState();\n    var nextIsSearchStalled = currentState.isSearchStalled;\n\n    if (!helper.hasPendingRequests()) {\n      clearTimeout(stalledSearchTimer);\n      nextIsSearchStalled = false;\n    }\n\n    var resultsFacetValues = currentState.resultsFacetValues,\n        partialState = _objectWithoutProperties(currentState, [\"resultsFacetValues\"]);\n\n    store.setState(_objectSpread({}, partialState, {\n      isSearchStalled: nextIsSearchStalled,\n      error: error,\n      searching: false\n    }));\n  }\n\n  function handleNewSearch() {\n    if (!stalledSearchTimer) {\n      stalledSearchTimer = setTimeout(function () {\n        var _store$getState = store.getState(),\n            resultsFacetValues = _store$getState.resultsFacetValues,\n            partialState = _objectWithoutProperties(_store$getState, [\"resultsFacetValues\"]);\n\n        store.setState(_objectSpread({}, partialState, {\n          isSearchStalled: true\n        }));\n      }, stalledSearchDelay);\n    }\n  }\n\n  function hydrateSearchClient(client, results) {\n    if (!results) {\n      return;\n    } // Disable cache hydration on:\n    // - Algoliasearch API Client < v4 with cache disabled\n    // - Third party clients (detected by the `addAlgoliaAgent` function missing)\n\n\n    if ((!client.transporter || client._cacheHydrated) && (!client._useCache || typeof client.addAlgoliaAgent !== 'function')) {\n      return;\n    } // Algoliasearch API Client >= v4\n    // To hydrate the client we need to populate the cache with the data from\n    // the server (done in `hydrateSearchClientWithMultiIndexRequest` or\n    // `hydrateSearchClientWithSingleIndexRequest`). But since there is no way\n    // for us to compute the key the same way as `algoliasearch-client` we need\n    // to populate it on a custom key and override the `search` method to\n    // search on it first.\n\n\n    if (client.transporter && !client._cacheHydrated) {\n      client._cacheHydrated = true;\n      var baseMethod = client.search;\n\n      client.search = function (requests) {\n        for (var _len2 = arguments.length, methodArgs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          methodArgs[_key2 - 1] = arguments[_key2];\n        }\n\n        var requestsWithSerializedParams = requests.map(function (request) {\n          return _objectSpread({}, request, {\n            params: serializeQueryParameters(request.params)\n          });\n        });\n        return client.transporter.responsesCache.get({\n          method: 'search',\n          args: [requestsWithSerializedParams].concat(methodArgs)\n        }, function () {\n          return baseMethod.apply(void 0, [requests].concat(methodArgs));\n        });\n      };\n    }\n\n    if (Array.isArray(results.results)) {\n      hydrateSearchClientWithMultiIndexRequest(client, results.results);\n      return;\n    }\n\n    hydrateSearchClientWithSingleIndexRequest(client, results);\n  }\n\n  function hydrateSearchClientWithMultiIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults.map(function (request) {\n            return {\n              indexName: request.index,\n              params: request.params\n            };\n          }));\n        }, [])]\n      }, {\n        results: results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults);\n        }, [])\n      });\n      return;\n    } // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n\n\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        }));\n      }, [])\n    }));\n    client.cache = _objectSpread({}, client.cache, _defineProperty({}, key, JSON.stringify({\n      results: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults);\n      }, [])\n    })));\n  }\n\n  function hydrateSearchClientWithSingleIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        })]\n      }, {\n        results: results.rawResults\n      });\n      return;\n    } // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n\n\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.rawResults.map(function (request) {\n        return {\n          indexName: request.index,\n          params: request.params\n        };\n      })\n    }));\n    client.cache = _objectSpread({}, client.cache, _defineProperty({}, key, JSON.stringify({\n      results: results.rawResults\n    })));\n  }\n\n  function hydrateResultsState(results) {\n    if (!results) {\n      return null;\n    }\n\n    if (Array.isArray(results.results)) {\n      return results.results.reduce(function (acc, result) {\n        return _objectSpread({}, acc, _defineProperty({}, result._internalIndexId, new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(result.state), result.rawResults)));\n      }, {});\n    }\n\n    return new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(results.state), results.rawResults);\n  } // Called whenever a widget has been rendered with new props.\n\n\n  function onWidgetsUpdate() {\n    var metadata = getMetadata(store.getState().widgets);\n    store.setState(_objectSpread({}, store.getState(), {\n      metadata: metadata,\n      searching: true\n    })); // Since the `getSearchParameters` method of widgets also depends on props,\n    // the result search parameters might have changed.\n\n    search();\n  }\n\n  function transitionState(nextSearchState) {\n    var searchState = store.getState().widgets;\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.transitionState);\n    }).reduce(function (res, widget) {\n      return widget.transitionState(searchState, res);\n    }, nextSearchState);\n  }\n\n  function onExternalStateUpdate(nextSearchState) {\n    var metadata = getMetadata(nextSearchState);\n    store.setState(_objectSpread({}, store.getState(), {\n      widgets: nextSearchState,\n      metadata: metadata,\n      searching: true\n    }));\n    search();\n  }\n\n  function onSearchForFacetValues(_ref5) {\n    var facetName = _ref5.facetName,\n        query = _ref5.query,\n        _ref5$maxFacetHits = _ref5.maxFacetHits,\n        maxFacetHits = _ref5$maxFacetHits === void 0 ? 10 : _ref5$maxFacetHits;\n    // The values 1, 100 are the min / max values that the engine accepts.\n    // see: https://www.algolia.com/doc/api-reference/api-parameters/maxFacetHits\n    var maxFacetHitsWithinRange = Math.max(1, Math.min(maxFacetHits, 100));\n    store.setState(_objectSpread({}, store.getState(), {\n      searchingForFacetValues: true\n    }));\n    helper.searchForFacetValues(facetName, query, maxFacetHitsWithinRange).then(function (content) {\n      var _objectSpread7;\n\n      store.setState(_objectSpread({}, store.getState(), {\n        error: null,\n        searchingForFacetValues: false,\n        resultsFacetValues: _objectSpread({}, store.getState().resultsFacetValues, (_objectSpread7 = {}, _defineProperty(_objectSpread7, facetName, content.facetHits), _defineProperty(_objectSpread7, \"query\", query), _objectSpread7))\n      }));\n    }, function (error) {\n      store.setState(_objectSpread({}, store.getState(), {\n        searchingForFacetValues: false,\n        error: error\n      }));\n    }).catch(function (error) {\n      // Since setState is synchronous, any error that occurs in the render of a\n      // component will be swallowed by this promise.\n      // This is a trick to make the error show up correctly in the console.\n      // See http://stackoverflow.com/a/30741722/969302\n      setTimeout(function () {\n        throw error;\n      });\n    });\n  }\n\n  function updateIndex(newIndex) {\n    initialSearchParameters = initialSearchParameters.setIndex(newIndex); // No need to trigger a new search here as the widgets will also update and trigger it if needed.\n  }\n\n  function getWidgetsIds() {\n    return store.getState().metadata.reduce(function (res, meta) {\n      return typeof meta.id !== 'undefined' ? res.concat(meta.id) : res;\n    }, []);\n  }\n\n  return {\n    store: store,\n    widgetsManager: widgetsManager,\n    getWidgetsIds: getWidgetsIds,\n    getSearchParameters: getSearchParameters,\n    onSearchForFacetValues: onSearchForFacetValues,\n    onExternalStateUpdate: onExternalStateUpdate,\n    transitionState: transitionState,\n    updateClient: updateClient,\n    updateIndex: updateIndex,\n    clearCache: clearCache,\n    skipSearch: skipSearch\n  };\n}\n\nfunction hydrateMetadata(resultsState) {\n  if (!resultsState) {\n    return [];\n  } // add a value noop, which gets replaced once the widgets are mounted\n\n\n  return resultsState.metadata.map(function (datum) {\n    return _objectSpread({\n      value: function value() {}\n    }, datum, {\n      items: datum.items && datum.items.map(function (item) {\n        return _objectSpread({\n          value: function value() {}\n        }, item, {\n          items: item.items && item.items.map(function (nestedItem) {\n            return _objectSpread({\n              value: function value() {}\n            }, nestedItem);\n          })\n        });\n      })\n    });\n  });\n}"]},"metadata":{},"sourceType":"module"}