{"ast":null,"code":"'use strict';\n\nvar merge = require('../functions/merge');\n\nvar defaultsPure = require('../functions/defaultsPure');\n\nvar orderBy = require('../functions/orderBy');\n\nvar compact = require('../functions/compact');\n\nvar find = require('../functions/find');\n\nvar findIndex = require('../functions/findIndex');\n\nvar formatSort = require('../functions/formatSort');\n\nvar generateHierarchicalTree = require('./generate-hierarchical-tree');\n/**\n * @typedef SearchResults.Facet\n * @type {object}\n * @property {string} name name of the attribute in the record\n * @property {object} data the faceting data: value, number of entries\n * @property {object} stats undefined unless facet_stats is retrieved from algolia\n */\n\n/**\n * @typedef SearchResults.HierarchicalFacet\n * @type {object}\n * @property {string} name name of the current value given the hierarchical level, trimmed.\n * If root node, you get the facet name\n * @property {number} count number of objects matching this hierarchical value\n * @property {string} path the current hierarchical value full path\n * @property {boolean} isRefined `true` if the current value was refined, `false` otherwise\n * @property {HierarchicalFacet[]} data sub values for the current level\n */\n\n/**\n * @typedef SearchResults.FacetValue\n * @type {object}\n * @property {string} name the facet value itself\n * @property {number} count times this facet appears in the results\n * @property {boolean} isRefined is the facet currently selected\n * @property {boolean} isExcluded is the facet currently excluded (only for conjunctive facets)\n */\n\n/**\n * @typedef Refinement\n * @type {object}\n * @property {string} type the type of filter used:\n * `numeric`, `facet`, `exclude`, `disjunctive`, `hierarchical`\n * @property {string} attributeName name of the attribute used for filtering\n * @property {string} name the value of the filter\n * @property {number} numericValue the value as a number. Only for numeric filters.\n * @property {string} operator the operator used. Only for numeric filters.\n * @property {number} count the number of computed hits for this filter. Only on facets.\n * @property {boolean} exhaustive if the count is exhaustive\n */\n\n/**\n * @param {string[]} attributes\n */\n\n\nfunction getIndices(attributes) {\n  var indices = {};\n  attributes.forEach(function (val, idx) {\n    indices[val] = idx;\n  });\n  return indices;\n}\n\nfunction assignFacetStats(dest, facetStats, key) {\n  if (facetStats && facetStats[key]) {\n    dest.stats = facetStats[key];\n  }\n}\n/**\n * @typedef {Object} HierarchicalFacet\n * @property {string} name\n * @property {string[]} attributes\n */\n\n/**\n * @param {HierarchicalFacet[]} hierarchicalFacets\n * @param {string} hierarchicalAttributeName\n */\n\n\nfunction findMatchingHierarchicalFacetFromAttributeName(hierarchicalFacets, hierarchicalAttributeName) {\n  return find(hierarchicalFacets, function facetKeyMatchesAttribute(hierarchicalFacet) {\n    var facetNames = hierarchicalFacet.attributes || [];\n    return facetNames.indexOf(hierarchicalAttributeName) > -1;\n  });\n}\n/*eslint-disable */\n\n/**\n * Constructor for SearchResults\n * @class\n * @classdesc SearchResults contains the results of a query to Algolia using the\n * {@link AlgoliaSearchHelper}.\n * @param {SearchParameters} state state that led to the response\n * @param {array.<object>} results the results from algolia client\n * @example <caption>SearchResults of the first query in\n * <a href=\"http://demos.algolia.com/instant-search-demo\">the instant search demo</a></caption>\n{\n   \"hitsPerPage\": 10,\n   \"processingTimeMS\": 2,\n   \"facets\": [\n      {\n         \"name\": \"type\",\n         \"data\": {\n            \"HardGood\": 6627,\n            \"BlackTie\": 550,\n            \"Music\": 665,\n            \"Software\": 131,\n            \"Game\": 456,\n            \"Movie\": 1571\n         },\n         \"exhaustive\": false\n      },\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"Free shipping\": 5507\n         },\n         \"name\": \"shipping\"\n      }\n  ],\n   \"hits\": [\n      {\n         \"thumbnailImage\": \"http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_54x108_s.gif\",\n         \"_highlightResult\": {\n            \"shortDescription\": {\n               \"matchLevel\": \"none\",\n               \"value\": \"Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection\",\n               \"matchedWords\": []\n            },\n            \"category\": {\n               \"matchLevel\": \"none\",\n               \"value\": \"Computer Security Software\",\n               \"matchedWords\": []\n            },\n            \"manufacturer\": {\n               \"matchedWords\": [],\n               \"value\": \"Webroot\",\n               \"matchLevel\": \"none\"\n            },\n            \"name\": {\n               \"value\": \"Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows\",\n               \"matchedWords\": [],\n               \"matchLevel\": \"none\"\n            }\n         },\n         \"image\": \"http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_105x210_sc.jpg\",\n         \"shipping\": \"Free shipping\",\n         \"bestSellingRank\": 4,\n         \"shortDescription\": \"Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection\",\n         \"url\": \"http://www.bestbuy.com/site/webroot-secureanywhere-internet-security-3-devi…d=1219060687969&skuId=1688832&cmp=RMX&ky=2d3GfEmNIzjA0vkzveHdZEBgpPCyMnLTJ\",\n         \"name\": \"Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows\",\n         \"category\": \"Computer Security Software\",\n         \"salePrice_range\": \"1 - 50\",\n         \"objectID\": \"1688832\",\n         \"type\": \"Software\",\n         \"customerReviewCount\": 5980,\n         \"salePrice\": 49.99,\n         \"manufacturer\": \"Webroot\"\n      },\n      ....\n  ],\n   \"nbHits\": 10000,\n   \"disjunctiveFacets\": [\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"5\": 183,\n            \"12\": 112,\n            \"7\": 149,\n            ...\n         },\n         \"name\": \"customerReviewCount\",\n         \"stats\": {\n            \"max\": 7461,\n            \"avg\": 157.939,\n            \"min\": 1\n         }\n      },\n      {\n         \"data\": {\n            \"Printer Ink\": 142,\n            \"Wireless Speakers\": 60,\n            \"Point & Shoot Cameras\": 48,\n            ...\n         },\n         \"name\": \"category\",\n         \"exhaustive\": false\n      },\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"> 5000\": 2,\n            \"1 - 50\": 6524,\n            \"501 - 2000\": 566,\n            \"201 - 500\": 1501,\n            \"101 - 200\": 1360,\n            \"2001 - 5000\": 47\n         },\n         \"name\": \"salePrice_range\"\n      },\n      {\n         \"data\": {\n            \"Dynex™\": 202,\n            \"Insignia™\": 230,\n            \"PNY\": 72,\n            ...\n         },\n         \"name\": \"manufacturer\",\n         \"exhaustive\": false\n      }\n  ],\n   \"query\": \"\",\n   \"nbPages\": 100,\n   \"page\": 0,\n   \"index\": \"bestbuy\"\n}\n **/\n\n/*eslint-enable */\n\n\nfunction SearchResults(state, results) {\n  var mainSubResponse = results[0];\n  this._rawResults = results;\n  var self = this; // https://www.algolia.com/doc/api-reference/api-methods/search/#response\n\n  Object.keys(mainSubResponse).forEach(function (key) {\n    self[key] = mainSubResponse[key];\n  });\n  /**\n   * query used to generate the results\n   * @name query\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   */\n\n  /**\n   * The query as parsed by the engine given all the rules.\n   * @name parsedQuery\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   */\n\n  /**\n   * all the records that match the search parameters. Each record is\n   * augmented with a new attribute `_highlightResult`\n   * which is an object keyed by attribute and with the following properties:\n   *  - `value` : the value of the facet highlighted (html)\n   *  - `matchLevel`: full, partial or none depending on how the query terms match\n   * @name hits\n   * @member {object[]}\n   * @memberof SearchResults\n   * @instance\n   */\n\n  /**\n   * index where the results come from\n   * @name index\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   */\n\n  /**\n   * number of hits per page requested\n   * @name hitsPerPage\n   * @member {number}\n   * @memberof SearchResults\n   * @instance\n   */\n\n  /**\n   * total number of hits of this query on the index\n   * @name nbHits\n   * @member {number}\n   * @memberof SearchResults\n   * @instance\n   */\n\n  /**\n   * total number of pages with respect to the number of hits per page and the total number of hits\n   * @name nbPages\n   * @member {number}\n   * @memberof SearchResults\n   * @instance\n   */\n\n  /**\n   * current page\n   * @name page\n   * @member {number}\n   * @memberof SearchResults\n   * @instance\n   */\n\n  /**\n   * The position if the position was guessed by IP.\n   * @name aroundLatLng\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   * @example \"48.8637,2.3615\",\n   */\n\n  /**\n   * The radius computed by Algolia.\n   * @name automaticRadius\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   * @example \"126792922\",\n   */\n\n  /**\n   * String identifying the server used to serve this request.\n   *\n   * getRankingInfo needs to be set to `true` for this to be returned\n   *\n   * @name serverUsed\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   * @example \"c7-use-2.algolia.net\",\n   */\n\n  /**\n   * Boolean that indicates if the computation of the counts did time out.\n   * @deprecated\n   * @name timeoutCounts\n   * @member {boolean}\n   * @memberof SearchResults\n   * @instance\n   */\n\n  /**\n   * Boolean that indicates if the computation of the hits did time out.\n   * @deprecated\n   * @name timeoutHits\n   * @member {boolean}\n   * @memberof SearchResults\n   * @instance\n   */\n\n  /**\n   * True if the counts of the facets is exhaustive\n   * @name exhaustiveFacetsCount\n   * @member {boolean}\n   * @memberof SearchResults\n   * @instance\n   */\n\n  /**\n   * True if the number of hits is exhaustive\n   * @name exhaustiveNbHits\n   * @member {boolean}\n   * @memberof SearchResults\n   * @instance\n   */\n\n  /**\n   * Contains the userData if they are set by a [query rule](https://www.algolia.com/doc/guides/query-rules/query-rules-overview/).\n   * @name userData\n   * @member {object[]}\n   * @memberof SearchResults\n   * @instance\n   */\n\n  /**\n   * queryID is the unique identifier of the query used to generate the current search results.\n   * This value is only available if the `clickAnalytics` search parameter is set to `true`.\n   * @name queryID\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   */\n\n  /**\n   * sum of the processing time of all the queries\n   * @member {number}\n   */\n\n  this.processingTimeMS = results.reduce(function (sum, result) {\n    return result.processingTimeMS === undefined ? sum : sum + result.processingTimeMS;\n  }, 0);\n  /**\n   * disjunctive facets results\n   * @member {SearchResults.Facet[]}\n   */\n\n  this.disjunctiveFacets = [];\n  /**\n   * disjunctive facets results\n   * @member {SearchResults.HierarchicalFacet[]}\n   */\n\n  this.hierarchicalFacets = state.hierarchicalFacets.map(function initFutureTree() {\n    return [];\n  });\n  /**\n   * other facets results\n   * @member {SearchResults.Facet[]}\n   */\n\n  this.facets = [];\n  var disjunctiveFacets = state.getRefinedDisjunctiveFacets();\n  var facetsIndices = getIndices(state.facets);\n  var disjunctiveFacetsIndices = getIndices(state.disjunctiveFacets);\n  var nextDisjunctiveResult = 1; // Since we send request only for disjunctive facets that have been refined,\n  // we get the facets information from the first, general, response.\n\n  var mainFacets = mainSubResponse.facets || {};\n  Object.keys(mainFacets).forEach(function (facetKey) {\n    var facetValueObject = mainFacets[facetKey];\n    var hierarchicalFacet = findMatchingHierarchicalFacetFromAttributeName(state.hierarchicalFacets, facetKey);\n\n    if (hierarchicalFacet) {\n      // Place the hierarchicalFacet data at the correct index depending on\n      // the attributes order that was defined at the helper initialization\n      var facetIndex = hierarchicalFacet.attributes.indexOf(facetKey);\n      var idxAttributeName = findIndex(state.hierarchicalFacets, function (f) {\n        return f.name === hierarchicalFacet.name;\n      });\n      self.hierarchicalFacets[idxAttributeName][facetIndex] = {\n        attribute: facetKey,\n        data: facetValueObject,\n        exhaustive: mainSubResponse.exhaustiveFacetsCount\n      };\n    } else {\n      var isFacetDisjunctive = state.disjunctiveFacets.indexOf(facetKey) !== -1;\n      var isFacetConjunctive = state.facets.indexOf(facetKey) !== -1;\n      var position;\n\n      if (isFacetDisjunctive) {\n        position = disjunctiveFacetsIndices[facetKey];\n        self.disjunctiveFacets[position] = {\n          name: facetKey,\n          data: facetValueObject,\n          exhaustive: mainSubResponse.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.disjunctiveFacets[position], mainSubResponse.facets_stats, facetKey);\n      }\n\n      if (isFacetConjunctive) {\n        position = facetsIndices[facetKey];\n        self.facets[position] = {\n          name: facetKey,\n          data: facetValueObject,\n          exhaustive: mainSubResponse.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.facets[position], mainSubResponse.facets_stats, facetKey);\n      }\n    }\n  }); // Make sure we do not keep holes within the hierarchical facets\n\n  this.hierarchicalFacets = compact(this.hierarchicalFacets); // aggregate the refined disjunctive facets\n\n  disjunctiveFacets.forEach(function (disjunctiveFacet) {\n    var result = results[nextDisjunctiveResult];\n    var facets = result && result.facets ? result.facets : {};\n    var hierarchicalFacet = state.getHierarchicalFacetByName(disjunctiveFacet); // There should be only item in facets.\n\n    Object.keys(facets).forEach(function (dfacet) {\n      var facetResults = facets[dfacet];\n      var position;\n\n      if (hierarchicalFacet) {\n        position = findIndex(state.hierarchicalFacets, function (f) {\n          return f.name === hierarchicalFacet.name;\n        });\n        var attributeIndex = findIndex(self.hierarchicalFacets[position], function (f) {\n          return f.attribute === dfacet;\n        }); // previous refinements and no results so not able to find it\n\n        if (attributeIndex === -1) {\n          return;\n        }\n\n        self.hierarchicalFacets[position][attributeIndex].data = merge({}, self.hierarchicalFacets[position][attributeIndex].data, facetResults);\n      } else {\n        position = disjunctiveFacetsIndices[dfacet];\n        var dataFromMainRequest = mainSubResponse.facets && mainSubResponse.facets[dfacet] || {};\n        self.disjunctiveFacets[position] = {\n          name: dfacet,\n          data: defaultsPure({}, facetResults, dataFromMainRequest),\n          exhaustive: result.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.disjunctiveFacets[position], result.facets_stats, dfacet);\n\n        if (state.disjunctiveFacetsRefinements[dfacet]) {\n          state.disjunctiveFacetsRefinements[dfacet].forEach(function (refinementValue) {\n            // add the disjunctive refinements if it is no more retrieved\n            if (!self.disjunctiveFacets[position].data[refinementValue] && state.disjunctiveFacetsRefinements[dfacet].indexOf(refinementValue) > -1) {\n              self.disjunctiveFacets[position].data[refinementValue] = 0;\n            }\n          });\n        }\n      }\n    });\n    nextDisjunctiveResult++;\n  }); // if we have some root level values for hierarchical facets, merge them\n\n  state.getRefinedHierarchicalFacets().forEach(function (refinedFacet) {\n    var hierarchicalFacet = state.getHierarchicalFacetByName(refinedFacet);\n\n    var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n\n    var currentRefinement = state.getHierarchicalRefinement(refinedFacet); // if we are already at a root refinement (or no refinement at all), there is no\n    // root level values request\n\n    if (currentRefinement.length === 0 || currentRefinement[0].split(separator).length < 2) {\n      return;\n    }\n\n    var result = results[nextDisjunctiveResult];\n    var facets = result && result.facets ? result.facets : {};\n    Object.keys(facets).forEach(function (dfacet) {\n      var facetResults = facets[dfacet];\n      var position = findIndex(state.hierarchicalFacets, function (f) {\n        return f.name === hierarchicalFacet.name;\n      });\n      var attributeIndex = findIndex(self.hierarchicalFacets[position], function (f) {\n        return f.attribute === dfacet;\n      }); // previous refinements and no results so not able to find it\n\n      if (attributeIndex === -1) {\n        return;\n      } // when we always get root levels, if the hits refinement is `beers > IPA` (count: 5),\n      // then the disjunctive values will be `beers` (count: 100),\n      // but we do not want to display\n      //   | beers (100)\n      //     > IPA (5)\n      // We want\n      //   | beers (5)\n      //     > IPA (5)\n\n\n      var defaultData = {};\n\n      if (currentRefinement.length > 0) {\n        var root = currentRefinement[0].split(separator)[0];\n        defaultData[root] = self.hierarchicalFacets[position][attributeIndex].data[root];\n      }\n\n      self.hierarchicalFacets[position][attributeIndex].data = defaultsPure(defaultData, facetResults, self.hierarchicalFacets[position][attributeIndex].data);\n    });\n    nextDisjunctiveResult++;\n  }); // add the excludes\n\n  Object.keys(state.facetsExcludes).forEach(function (facetName) {\n    var excludes = state.facetsExcludes[facetName];\n    var position = facetsIndices[facetName];\n    self.facets[position] = {\n      name: facetName,\n      data: mainSubResponse.facets[facetName],\n      exhaustive: mainSubResponse.exhaustiveFacetsCount\n    };\n    excludes.forEach(function (facetValue) {\n      self.facets[position] = self.facets[position] || {\n        name: facetName\n      };\n      self.facets[position].data = self.facets[position].data || {};\n      self.facets[position].data[facetValue] = 0;\n    });\n  });\n  /**\n   * @type {Array}\n   */\n\n  this.hierarchicalFacets = this.hierarchicalFacets.map(generateHierarchicalTree(state));\n  /**\n   * @type {Array}\n   */\n\n  this.facets = compact(this.facets);\n  /**\n   * @type {Array}\n   */\n\n  this.disjunctiveFacets = compact(this.disjunctiveFacets);\n  this._state = state;\n}\n/**\n * Get a facet object with its name\n * @deprecated\n * @param {string} name name of the faceted attribute\n * @return {SearchResults.Facet} the facet object\n */\n\n\nSearchResults.prototype.getFacetByName = function (name) {\n  function predicate(facet) {\n    return facet.name === name;\n  }\n\n  return find(this.facets, predicate) || find(this.disjunctiveFacets, predicate) || find(this.hierarchicalFacets, predicate);\n};\n/**\n * Get the facet values of a specified attribute from a SearchResults object.\n * @private\n * @param {SearchResults} results the search results to search in\n * @param {string} attribute name of the faceted attribute to search for\n * @return {array|object} facet values. For the hierarchical facets it is an object.\n */\n\n\nfunction extractNormalizedFacetValues(results, attribute) {\n  function predicate(facet) {\n    return facet.name === attribute;\n  }\n\n  if (results._state.isConjunctiveFacet(attribute)) {\n    var facet = find(results.facets, predicate);\n    if (!facet) return [];\n    return Object.keys(facet.data).map(function (name) {\n      return {\n        name: name,\n        count: facet.data[name],\n        isRefined: results._state.isFacetRefined(attribute, name),\n        isExcluded: results._state.isExcludeRefined(attribute, name)\n      };\n    });\n  } else if (results._state.isDisjunctiveFacet(attribute)) {\n    var disjunctiveFacet = find(results.disjunctiveFacets, predicate);\n    if (!disjunctiveFacet) return [];\n    return Object.keys(disjunctiveFacet.data).map(function (name) {\n      return {\n        name: name,\n        count: disjunctiveFacet.data[name],\n        isRefined: results._state.isDisjunctiveFacetRefined(attribute, name)\n      };\n    });\n  } else if (results._state.isHierarchicalFacet(attribute)) {\n    return find(results.hierarchicalFacets, predicate);\n  }\n}\n/**\n * Sort nodes of a hierarchical facet results\n * @private\n * @param {HierarchicalFacet} node node to upon which we want to apply the sort\n */\n\n\nfunction recSort(sortFn, node) {\n  if (!node.data || node.data.length === 0) {\n    return node;\n  }\n\n  var children = node.data.map(function (childNode) {\n    return recSort(sortFn, childNode);\n  });\n  var sortedChildren = sortFn(children);\n  var newNode = merge({}, node, {\n    data: sortedChildren\n  });\n  return newNode;\n}\n\nSearchResults.DEFAULT_SORT = ['isRefined:desc', 'count:desc', 'name:asc'];\n\nfunction vanillaSortFn(order, data) {\n  return data.sort(order);\n}\n/**\n * Get a the list of values for a given facet attribute. Those values are sorted\n * refinement first, descending count (bigger value on top), and name ascending\n * (alphabetical order). The sort formula can overridden using either string based\n * predicates or a function.\n *\n * This method will return all the values returned by the Algolia engine plus all\n * the values already refined. This means that it can happen that the\n * `maxValuesPerFacet` [configuration](https://www.algolia.com/doc/rest-api/search#param-maxValuesPerFacet)\n * might not be respected if you have facet values that are already refined.\n * @param {string} attribute attribute name\n * @param {object} opts configuration options.\n * @param {Array.<string> | function} opts.sortBy\n * When using strings, it consists of\n * the name of the [FacetValue](#SearchResults.FacetValue) or the\n * [HierarchicalFacet](#SearchResults.HierarchicalFacet) attributes with the\n * order (`asc` or `desc`). For example to order the value by count, the\n * argument would be `['count:asc']`.\n *\n * If only the attribute name is specified, the ordering defaults to the one\n * specified in the default value for this attribute.\n *\n * When not specified, the order is\n * ascending.  This parameter can also be a function which takes two facet\n * values and should return a number, 0 if equal, 1 if the first argument is\n * bigger or -1 otherwise.\n *\n * The default value for this attribute `['isRefined:desc', 'count:desc', 'name:asc']`\n * @return {FacetValue[]|HierarchicalFacet|undefined} depending on the type of facet of\n * the attribute requested (hierarchical, disjunctive or conjunctive)\n * @example\n * helper.on('result', function(event){\n *   //get values ordered only by name ascending using the string predicate\n *   event.results.getFacetValues('city', {sortBy: ['name:asc']});\n *   //get values  ordered only by count ascending using a function\n *   event.results.getFacetValues('city', {\n *     // this is equivalent to ['count:asc']\n *     sortBy: function(a, b) {\n *       if (a.count === b.count) return 0;\n *       if (a.count > b.count)   return 1;\n *       if (b.count > a.count)   return -1;\n *     }\n *   });\n * });\n */\n\n\nSearchResults.prototype.getFacetValues = function (attribute, opts) {\n  var facetValues = extractNormalizedFacetValues(this, attribute);\n\n  if (!facetValues) {\n    return undefined;\n  }\n\n  var options = defaultsPure({}, opts, {\n    sortBy: SearchResults.DEFAULT_SORT\n  });\n\n  if (Array.isArray(options.sortBy)) {\n    var order = formatSort(options.sortBy, SearchResults.DEFAULT_SORT);\n\n    if (Array.isArray(facetValues)) {\n      return orderBy(facetValues, order[0], order[1]);\n    } // If facetValues is not an array, it's an object thus a hierarchical facet object\n\n\n    return recSort(function (hierarchicalFacetValues) {\n      return orderBy(hierarchicalFacetValues, order[0], order[1]);\n    }, facetValues);\n  } else if (typeof options.sortBy === 'function') {\n    if (Array.isArray(facetValues)) {\n      return facetValues.sort(options.sortBy);\n    } // If facetValues is not an array, it's an object thus a hierarchical facet object\n\n\n    return recSort(function (data) {\n      return vanillaSortFn(options.sortBy, data);\n    }, facetValues);\n  }\n\n  throw new Error('options.sortBy is optional but if defined it must be ' + 'either an array of string (predicates) or a sorting function');\n};\n/**\n * Returns the facet stats if attribute is defined and the facet contains some.\n * Otherwise returns undefined.\n * @param {string} attribute name of the faceted attribute\n * @return {object} The stats of the facet\n */\n\n\nSearchResults.prototype.getFacetStats = function (attribute) {\n  if (this._state.isConjunctiveFacet(attribute)) {\n    return getFacetStatsIfAvailable(this.facets, attribute);\n  } else if (this._state.isDisjunctiveFacet(attribute)) {\n    return getFacetStatsIfAvailable(this.disjunctiveFacets, attribute);\n  }\n\n  return undefined;\n};\n/**\n * @typedef {Object} FacetListItem\n * @property {string} name\n */\n\n/**\n * @param {FacetListItem[]} facetList (has more items, but enough for here)\n * @param {string} facetName\n */\n\n\nfunction getFacetStatsIfAvailable(facetList, facetName) {\n  var data = find(facetList, function (facet) {\n    return facet.name === facetName;\n  });\n  return data && data.stats;\n}\n/**\n * Returns all refinements for all filters + tags. It also provides\n * additional information: count and exhaustiveness for each filter.\n *\n * See the [refinement type](#Refinement) for an exhaustive view of the available\n * data.\n *\n * Note that for a numeric refinement, results are grouped per operator, this\n * means that it will return responses for operators which are empty.\n *\n * @return {Array.<Refinement>} all the refinements\n */\n\n\nSearchResults.prototype.getRefinements = function () {\n  var state = this._state;\n  var results = this;\n  var res = [];\n  Object.keys(state.facetsRefinements).forEach(function (attributeName) {\n    state.facetsRefinements[attributeName].forEach(function (name) {\n      res.push(getRefinement(state, 'facet', attributeName, name, results.facets));\n    });\n  });\n  Object.keys(state.facetsExcludes).forEach(function (attributeName) {\n    state.facetsExcludes[attributeName].forEach(function (name) {\n      res.push(getRefinement(state, 'exclude', attributeName, name, results.facets));\n    });\n  });\n  Object.keys(state.disjunctiveFacetsRefinements).forEach(function (attributeName) {\n    state.disjunctiveFacetsRefinements[attributeName].forEach(function (name) {\n      res.push(getRefinement(state, 'disjunctive', attributeName, name, results.disjunctiveFacets));\n    });\n  });\n  Object.keys(state.hierarchicalFacetsRefinements).forEach(function (attributeName) {\n    state.hierarchicalFacetsRefinements[attributeName].forEach(function (name) {\n      res.push(getHierarchicalRefinement(state, attributeName, name, results.hierarchicalFacets));\n    });\n  });\n  Object.keys(state.numericRefinements).forEach(function (attributeName) {\n    var operators = state.numericRefinements[attributeName];\n    Object.keys(operators).forEach(function (operator) {\n      operators[operator].forEach(function (value) {\n        res.push({\n          type: 'numeric',\n          attributeName: attributeName,\n          name: value,\n          numericValue: value,\n          operator: operator\n        });\n      });\n    });\n  });\n  state.tagRefinements.forEach(function (name) {\n    res.push({\n      type: 'tag',\n      attributeName: '_tags',\n      name: name\n    });\n  });\n  return res;\n};\n/**\n * @typedef {Object} Facet\n * @property {string} name\n * @property {Object} data\n * @property {boolean} exhaustive\n */\n\n/**\n * @param {*} state\n * @param {*} type\n * @param {string} attributeName\n * @param {*} name\n * @param {Facet[]} resultsFacets\n */\n\n\nfunction getRefinement(state, type, attributeName, name, resultsFacets) {\n  var facet = find(resultsFacets, function (f) {\n    return f.name === attributeName;\n  });\n  var count = facet && facet.data && facet.data[name] ? facet.data[name] : 0;\n  var exhaustive = facet && facet.exhaustive || false;\n  return {\n    type: type,\n    attributeName: attributeName,\n    name: name,\n    count: count,\n    exhaustive: exhaustive\n  };\n}\n/**\n * @param {*} state\n * @param {string} attributeName\n * @param {*} name\n * @param {Facet[]} resultsFacets\n */\n\n\nfunction getHierarchicalRefinement(state, attributeName, name, resultsFacets) {\n  var facetDeclaration = state.getHierarchicalFacetByName(attributeName);\n\n  var separator = state._getHierarchicalFacetSeparator(facetDeclaration);\n\n  var split = name.split(separator);\n  var rootFacet = find(resultsFacets, function (facet) {\n    return facet.name === attributeName;\n  });\n  var facet = split.reduce(function (intermediateFacet, part) {\n    var newFacet = intermediateFacet && find(intermediateFacet.data, function (f) {\n      return f.name === part;\n    });\n    return newFacet !== undefined ? newFacet : intermediateFacet;\n  }, rootFacet);\n  var count = facet && facet.count || 0;\n  var exhaustive = facet && facet.exhaustive || false;\n  var path = facet && facet.path || '';\n  return {\n    type: 'hierarchical',\n    attributeName: attributeName,\n    name: path,\n    count: count,\n    exhaustive: exhaustive\n  };\n}\n\nmodule.exports = SearchResults;","map":{"version":3,"sources":["C:/Users/Murtaza Jafari/Desktop/product-search/product/searcbox/node_modules/algoliasearch-helper/src/SearchResults/index.js"],"names":["merge","require","defaultsPure","orderBy","compact","find","findIndex","formatSort","generateHierarchicalTree","getIndices","attributes","indices","forEach","val","idx","assignFacetStats","dest","facetStats","key","stats","findMatchingHierarchicalFacetFromAttributeName","hierarchicalFacets","hierarchicalAttributeName","facetKeyMatchesAttribute","hierarchicalFacet","facetNames","indexOf","SearchResults","state","results","mainSubResponse","_rawResults","self","Object","keys","processingTimeMS","reduce","sum","result","undefined","disjunctiveFacets","map","initFutureTree","facets","getRefinedDisjunctiveFacets","facetsIndices","disjunctiveFacetsIndices","nextDisjunctiveResult","mainFacets","facetKey","facetValueObject","facetIndex","idxAttributeName","f","name","attribute","data","exhaustive","exhaustiveFacetsCount","isFacetDisjunctive","isFacetConjunctive","position","facets_stats","disjunctiveFacet","getHierarchicalFacetByName","dfacet","facetResults","attributeIndex","dataFromMainRequest","disjunctiveFacetsRefinements","refinementValue","getRefinedHierarchicalFacets","refinedFacet","separator","_getHierarchicalFacetSeparator","currentRefinement","getHierarchicalRefinement","length","split","defaultData","root","facetsExcludes","facetName","excludes","facetValue","_state","prototype","getFacetByName","predicate","facet","extractNormalizedFacetValues","isConjunctiveFacet","count","isRefined","isFacetRefined","isExcluded","isExcludeRefined","isDisjunctiveFacet","isDisjunctiveFacetRefined","isHierarchicalFacet","recSort","sortFn","node","children","childNode","sortedChildren","newNode","DEFAULT_SORT","vanillaSortFn","order","sort","getFacetValues","opts","facetValues","options","sortBy","Array","isArray","hierarchicalFacetValues","Error","getFacetStats","getFacetStatsIfAvailable","facetList","getRefinements","res","facetsRefinements","attributeName","push","getRefinement","hierarchicalFacetsRefinements","numericRefinements","operators","operator","value","type","numericValue","tagRefinements","resultsFacets","facetDeclaration","rootFacet","intermediateFacet","part","newFacet","path","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,oBAAD,CAAnB;;AACA,IAAIC,YAAY,GAAGD,OAAO,CAAC,2BAAD,CAA1B;;AACA,IAAIE,OAAO,GAAGF,OAAO,CAAC,sBAAD,CAArB;;AACA,IAAIG,OAAO,GAAGH,OAAO,CAAC,sBAAD,CAArB;;AACA,IAAII,IAAI,GAAGJ,OAAO,CAAC,mBAAD,CAAlB;;AACA,IAAIK,SAAS,GAAGL,OAAO,CAAC,wBAAD,CAAvB;;AACA,IAAIM,UAAU,GAAGN,OAAO,CAAC,yBAAD,CAAxB;;AAEA,IAAIO,wBAAwB,GAAGP,OAAO,CAAC,8BAAD,CAAtC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AACA,SAASQ,UAAT,CAAoBC,UAApB,EAAgC;AAC9B,MAAIC,OAAO,GAAG,EAAd;AAEAD,EAAAA,UAAU,CAACE,OAAX,CAAmB,UAASC,GAAT,EAAcC,GAAd,EAAmB;AACpCH,IAAAA,OAAO,CAACE,GAAD,CAAP,GAAeC,GAAf;AACD,GAFD;AAIA,SAAOH,OAAP;AACD;;AAED,SAASI,gBAAT,CAA0BC,IAA1B,EAAgCC,UAAhC,EAA4CC,GAA5C,EAAiD;AAC/C,MAAID,UAAU,IAAIA,UAAU,CAACC,GAAD,CAA5B,EAAmC;AACjCF,IAAAA,IAAI,CAACG,KAAL,GAAaF,UAAU,CAACC,GAAD,CAAvB;AACD;AACF;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AACA,SAASE,8CAAT,CACEC,kBADF,EAEEC,yBAFF,EAGE;AACA,SAAOjB,IAAI,CAACgB,kBAAD,EAAqB,SAASE,wBAAT,CAC9BC,iBAD8B,EAE9B;AACA,QAAIC,UAAU,GAAGD,iBAAiB,CAACd,UAAlB,IAAgC,EAAjD;AACA,WAAOe,UAAU,CAACC,OAAX,CAAmBJ,yBAAnB,IAAgD,CAAC,CAAxD;AACD,GALU,CAAX;AAMD;AAED;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AACA,SAASK,aAAT,CAAuBC,KAAvB,EAA8BC,OAA9B,EAAuC;AACrC,MAAIC,eAAe,GAAGD,OAAO,CAAC,CAAD,CAA7B;AAEA,OAAKE,WAAL,GAAmBF,OAAnB;AAEA,MAAIG,IAAI,GAAG,IAAX,CALqC,CAOrC;;AACAC,EAAAA,MAAM,CAACC,IAAP,CAAYJ,eAAZ,EAA6BlB,OAA7B,CAAqC,UAASM,GAAT,EAAc;AACjDc,IAAAA,IAAI,CAACd,GAAD,CAAJ,GAAYY,eAAe,CAACZ,GAAD,CAA3B;AACD,GAFD;AAIA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE;AACF;AACA;AACA;AACA;AACA;AACA;;AACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE;AACF;AACA;AACA;AACA;AACA;AACA;;AACE;AACF;AACA;AACA;AACA;AACA;AACA;;AACE;AACF;AACA;AACA;AACA;AACA;AACA;;AACE;AACF;AACA;AACA;AACA;AACA;AACA;;AACE;AACF;AACA;AACA;AACA;AACA;AACA;;AACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE;AACF;AACA;AACA;AACA;AACA;AACA;;AACE;AACF;AACA;AACA;AACA;AACA;AACA;;AACE;AACF;AACA;AACA;AACA;AACA;AACA;;AACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;;AACE,OAAKiB,gBAAL,GAAwBN,OAAO,CAACO,MAAR,CAAe,UAASC,GAAT,EAAcC,MAAd,EAAsB;AAC3D,WAAOA,MAAM,CAACH,gBAAP,KAA4BI,SAA5B,GACHF,GADG,GAEHA,GAAG,GAAGC,MAAM,CAACH,gBAFjB;AAGD,GAJuB,EAIrB,CAJqB,CAAxB;AAMA;AACF;AACA;AACA;;AACE,OAAKK,iBAAL,GAAyB,EAAzB;AACA;AACF;AACA;AACA;;AACE,OAAKnB,kBAAL,GAA0BO,KAAK,CAACP,kBAAN,CAAyBoB,GAAzB,CAA6B,SAASC,cAAT,GAA0B;AAC/E,WAAO,EAAP;AACD,GAFyB,CAA1B;AAGA;AACF;AACA;AACA;;AACE,OAAKC,MAAL,GAAc,EAAd;AAEA,MAAIH,iBAAiB,GAAGZ,KAAK,CAACgB,2BAAN,EAAxB;AAEA,MAAIC,aAAa,GAAGpC,UAAU,CAACmB,KAAK,CAACe,MAAP,CAA9B;AACA,MAAIG,wBAAwB,GAAGrC,UAAU,CAACmB,KAAK,CAACY,iBAAP,CAAzC;AACA,MAAIO,qBAAqB,GAAG,CAA5B,CAjLqC,CAmLrC;AACA;;AAEA,MAAIC,UAAU,GAAGlB,eAAe,CAACa,MAAhB,IAA0B,EAA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","sourcesContent":["'use strict';\n\nvar merge = require('../functions/merge');\nvar defaultsPure = require('../functions/defaultsPure');\nvar orderBy = require('../functions/orderBy');\nvar compact = require('../functions/compact');\nvar find = require('../functions/find');\nvar findIndex = require('../functions/findIndex');\nvar formatSort = require('../functions/formatSort');\n\nvar generateHierarchicalTree = require('./generate-hierarchical-tree');\n\n/**\n * @typedef SearchResults.Facet\n * @type {object}\n * @property {string} name name of the attribute in the record\n * @property {object} data the faceting data: value, number of entries\n * @property {object} stats undefined unless facet_stats is retrieved from algolia\n */\n\n/**\n * @typedef SearchResults.HierarchicalFacet\n * @type {object}\n * @property {string} name name of the current value given the hierarchical level, trimmed.\n * If root node, you get the facet name\n * @property {number} count number of objects matching this hierarchical value\n * @property {string} path the current hierarchical value full path\n * @property {boolean} isRefined `true` if the current value was refined, `false` otherwise\n * @property {HierarchicalFacet[]} data sub values for the current level\n */\n\n/**\n * @typedef SearchResults.FacetValue\n * @type {object}\n * @property {string} name the facet value itself\n * @property {number} count times this facet appears in the results\n * @property {boolean} isRefined is the facet currently selected\n * @property {boolean} isExcluded is the facet currently excluded (only for conjunctive facets)\n */\n\n/**\n * @typedef Refinement\n * @type {object}\n * @property {string} type the type of filter used:\n * `numeric`, `facet`, `exclude`, `disjunctive`, `hierarchical`\n * @property {string} attributeName name of the attribute used for filtering\n * @property {string} name the value of the filter\n * @property {number} numericValue the value as a number. Only for numeric filters.\n * @property {string} operator the operator used. Only for numeric filters.\n * @property {number} count the number of computed hits for this filter. Only on facets.\n * @property {boolean} exhaustive if the count is exhaustive\n */\n\n/**\n * @param {string[]} attributes\n */\nfunction getIndices(attributes) {\n  var indices = {};\n\n  attributes.forEach(function(val, idx) {\n    indices[val] = idx;\n  });\n\n  return indices;\n}\n\nfunction assignFacetStats(dest, facetStats, key) {\n  if (facetStats && facetStats[key]) {\n    dest.stats = facetStats[key];\n  }\n}\n\n/**\n * @typedef {Object} HierarchicalFacet\n * @property {string} name\n * @property {string[]} attributes\n */\n\n/**\n * @param {HierarchicalFacet[]} hierarchicalFacets\n * @param {string} hierarchicalAttributeName\n */\nfunction findMatchingHierarchicalFacetFromAttributeName(\n  hierarchicalFacets,\n  hierarchicalAttributeName\n) {\n  return find(hierarchicalFacets, function facetKeyMatchesAttribute(\n    hierarchicalFacet\n  ) {\n    var facetNames = hierarchicalFacet.attributes || [];\n    return facetNames.indexOf(hierarchicalAttributeName) > -1;\n  });\n}\n\n/*eslint-disable */\n/**\n * Constructor for SearchResults\n * @class\n * @classdesc SearchResults contains the results of a query to Algolia using the\n * {@link AlgoliaSearchHelper}.\n * @param {SearchParameters} state state that led to the response\n * @param {array.<object>} results the results from algolia client\n * @example <caption>SearchResults of the first query in\n * <a href=\"http://demos.algolia.com/instant-search-demo\">the instant search demo</a></caption>\n{\n   \"hitsPerPage\": 10,\n   \"processingTimeMS\": 2,\n   \"facets\": [\n      {\n         \"name\": \"type\",\n         \"data\": {\n            \"HardGood\": 6627,\n            \"BlackTie\": 550,\n            \"Music\": 665,\n            \"Software\": 131,\n            \"Game\": 456,\n            \"Movie\": 1571\n         },\n         \"exhaustive\": false\n      },\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"Free shipping\": 5507\n         },\n         \"name\": \"shipping\"\n      }\n  ],\n   \"hits\": [\n      {\n         \"thumbnailImage\": \"http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_54x108_s.gif\",\n         \"_highlightResult\": {\n            \"shortDescription\": {\n               \"matchLevel\": \"none\",\n               \"value\": \"Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection\",\n               \"matchedWords\": []\n            },\n            \"category\": {\n               \"matchLevel\": \"none\",\n               \"value\": \"Computer Security Software\",\n               \"matchedWords\": []\n            },\n            \"manufacturer\": {\n               \"matchedWords\": [],\n               \"value\": \"Webroot\",\n               \"matchLevel\": \"none\"\n            },\n            \"name\": {\n               \"value\": \"Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows\",\n               \"matchedWords\": [],\n               \"matchLevel\": \"none\"\n            }\n         },\n         \"image\": \"http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_105x210_sc.jpg\",\n         \"shipping\": \"Free shipping\",\n         \"bestSellingRank\": 4,\n         \"shortDescription\": \"Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection\",\n         \"url\": \"http://www.bestbuy.com/site/webroot-secureanywhere-internet-security-3-devi…d=1219060687969&skuId=1688832&cmp=RMX&ky=2d3GfEmNIzjA0vkzveHdZEBgpPCyMnLTJ\",\n         \"name\": \"Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows\",\n         \"category\": \"Computer Security Software\",\n         \"salePrice_range\": \"1 - 50\",\n         \"objectID\": \"1688832\",\n         \"type\": \"Software\",\n         \"customerReviewCount\": 5980,\n         \"salePrice\": 49.99,\n         \"manufacturer\": \"Webroot\"\n      },\n      ....\n  ],\n   \"nbHits\": 10000,\n   \"disjunctiveFacets\": [\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"5\": 183,\n            \"12\": 112,\n            \"7\": 149,\n            ...\n         },\n         \"name\": \"customerReviewCount\",\n         \"stats\": {\n            \"max\": 7461,\n            \"avg\": 157.939,\n            \"min\": 1\n         }\n      },\n      {\n         \"data\": {\n            \"Printer Ink\": 142,\n            \"Wireless Speakers\": 60,\n            \"Point & Shoot Cameras\": 48,\n            ...\n         },\n         \"name\": \"category\",\n         \"exhaustive\": false\n      },\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"> 5000\": 2,\n            \"1 - 50\": 6524,\n            \"501 - 2000\": 566,\n            \"201 - 500\": 1501,\n            \"101 - 200\": 1360,\n            \"2001 - 5000\": 47\n         },\n         \"name\": \"salePrice_range\"\n      },\n      {\n         \"data\": {\n            \"Dynex™\": 202,\n            \"Insignia™\": 230,\n            \"PNY\": 72,\n            ...\n         },\n         \"name\": \"manufacturer\",\n         \"exhaustive\": false\n      }\n  ],\n   \"query\": \"\",\n   \"nbPages\": 100,\n   \"page\": 0,\n   \"index\": \"bestbuy\"\n}\n **/\n/*eslint-enable */\nfunction SearchResults(state, results) {\n  var mainSubResponse = results[0];\n\n  this._rawResults = results;\n\n  var self = this;\n\n  // https://www.algolia.com/doc/api-reference/api-methods/search/#response\n  Object.keys(mainSubResponse).forEach(function(key) {\n    self[key] = mainSubResponse[key];\n  });\n\n  /**\n   * query used to generate the results\n   * @name query\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * The query as parsed by the engine given all the rules.\n   * @name parsedQuery\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * all the records that match the search parameters. Each record is\n   * augmented with a new attribute `_highlightResult`\n   * which is an object keyed by attribute and with the following properties:\n   *  - `value` : the value of the facet highlighted (html)\n   *  - `matchLevel`: full, partial or none depending on how the query terms match\n   * @name hits\n   * @member {object[]}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * index where the results come from\n   * @name index\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * number of hits per page requested\n   * @name hitsPerPage\n   * @member {number}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * total number of hits of this query on the index\n   * @name nbHits\n   * @member {number}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * total number of pages with respect to the number of hits per page and the total number of hits\n   * @name nbPages\n   * @member {number}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * current page\n   * @name page\n   * @member {number}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * The position if the position was guessed by IP.\n   * @name aroundLatLng\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   * @example \"48.8637,2.3615\",\n   */\n  /**\n   * The radius computed by Algolia.\n   * @name automaticRadius\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   * @example \"126792922\",\n   */\n  /**\n   * String identifying the server used to serve this request.\n   *\n   * getRankingInfo needs to be set to `true` for this to be returned\n   *\n   * @name serverUsed\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   * @example \"c7-use-2.algolia.net\",\n   */\n  /**\n   * Boolean that indicates if the computation of the counts did time out.\n   * @deprecated\n   * @name timeoutCounts\n   * @member {boolean}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * Boolean that indicates if the computation of the hits did time out.\n   * @deprecated\n   * @name timeoutHits\n   * @member {boolean}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * True if the counts of the facets is exhaustive\n   * @name exhaustiveFacetsCount\n   * @member {boolean}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * True if the number of hits is exhaustive\n   * @name exhaustiveNbHits\n   * @member {boolean}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * Contains the userData if they are set by a [query rule](https://www.algolia.com/doc/guides/query-rules/query-rules-overview/).\n   * @name userData\n   * @member {object[]}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * queryID is the unique identifier of the query used to generate the current search results.\n   * This value is only available if the `clickAnalytics` search parameter is set to `true`.\n   * @name queryID\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   */\n\n  /**\n   * sum of the processing time of all the queries\n   * @member {number}\n   */\n  this.processingTimeMS = results.reduce(function(sum, result) {\n    return result.processingTimeMS === undefined\n      ? sum\n      : sum + result.processingTimeMS;\n  }, 0);\n\n  /**\n   * disjunctive facets results\n   * @member {SearchResults.Facet[]}\n   */\n  this.disjunctiveFacets = [];\n  /**\n   * disjunctive facets results\n   * @member {SearchResults.HierarchicalFacet[]}\n   */\n  this.hierarchicalFacets = state.hierarchicalFacets.map(function initFutureTree() {\n    return [];\n  });\n  /**\n   * other facets results\n   * @member {SearchResults.Facet[]}\n   */\n  this.facets = [];\n\n  var disjunctiveFacets = state.getRefinedDisjunctiveFacets();\n\n  var facetsIndices = getIndices(state.facets);\n  var disjunctiveFacetsIndices = getIndices(state.disjunctiveFacets);\n  var nextDisjunctiveResult = 1;\n\n  // Since we send request only for disjunctive facets that have been refined,\n  // we get the facets information from the first, general, response.\n\n  var mainFacets = mainSubResponse.facets || {};\n\n  Object.keys(mainFacets).forEach(function(facetKey) {\n    var facetValueObject = mainFacets[facetKey];\n\n    var hierarchicalFacet = findMatchingHierarchicalFacetFromAttributeName(\n      state.hierarchicalFacets,\n      facetKey\n    );\n\n    if (hierarchicalFacet) {\n      // Place the hierarchicalFacet data at the correct index depending on\n      // the attributes order that was defined at the helper initialization\n      var facetIndex = hierarchicalFacet.attributes.indexOf(facetKey);\n      var idxAttributeName = findIndex(state.hierarchicalFacets, function(f) {\n        return f.name === hierarchicalFacet.name;\n      });\n      self.hierarchicalFacets[idxAttributeName][facetIndex] = {\n        attribute: facetKey,\n        data: facetValueObject,\n        exhaustive: mainSubResponse.exhaustiveFacetsCount\n      };\n    } else {\n      var isFacetDisjunctive = state.disjunctiveFacets.indexOf(facetKey) !== -1;\n      var isFacetConjunctive = state.facets.indexOf(facetKey) !== -1;\n      var position;\n\n      if (isFacetDisjunctive) {\n        position = disjunctiveFacetsIndices[facetKey];\n        self.disjunctiveFacets[position] = {\n          name: facetKey,\n          data: facetValueObject,\n          exhaustive: mainSubResponse.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.disjunctiveFacets[position], mainSubResponse.facets_stats, facetKey);\n      }\n      if (isFacetConjunctive) {\n        position = facetsIndices[facetKey];\n        self.facets[position] = {\n          name: facetKey,\n          data: facetValueObject,\n          exhaustive: mainSubResponse.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.facets[position], mainSubResponse.facets_stats, facetKey);\n      }\n    }\n  });\n\n  // Make sure we do not keep holes within the hierarchical facets\n  this.hierarchicalFacets = compact(this.hierarchicalFacets);\n\n  // aggregate the refined disjunctive facets\n  disjunctiveFacets.forEach(function(disjunctiveFacet) {\n    var result = results[nextDisjunctiveResult];\n    var facets = result && result.facets ? result.facets : {};\n    var hierarchicalFacet = state.getHierarchicalFacetByName(disjunctiveFacet);\n\n    // There should be only item in facets.\n    Object.keys(facets).forEach(function(dfacet) {\n      var facetResults = facets[dfacet];\n\n      var position;\n\n      if (hierarchicalFacet) {\n        position = findIndex(state.hierarchicalFacets, function(f) {\n          return f.name === hierarchicalFacet.name;\n        });\n        var attributeIndex = findIndex(self.hierarchicalFacets[position], function(f) {\n          return f.attribute === dfacet;\n        });\n\n        // previous refinements and no results so not able to find it\n        if (attributeIndex === -1) {\n          return;\n        }\n\n        self.hierarchicalFacets[position][attributeIndex].data = merge(\n          {},\n          self.hierarchicalFacets[position][attributeIndex].data,\n          facetResults\n        );\n      } else {\n        position = disjunctiveFacetsIndices[dfacet];\n\n        var dataFromMainRequest = mainSubResponse.facets && mainSubResponse.facets[dfacet] || {};\n\n        self.disjunctiveFacets[position] = {\n          name: dfacet,\n          data: defaultsPure({}, facetResults, dataFromMainRequest),\n          exhaustive: result.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.disjunctiveFacets[position], result.facets_stats, dfacet);\n\n        if (state.disjunctiveFacetsRefinements[dfacet]) {\n          state.disjunctiveFacetsRefinements[dfacet].forEach(function(refinementValue) {\n            // add the disjunctive refinements if it is no more retrieved\n            if (!self.disjunctiveFacets[position].data[refinementValue] &&\n              state.disjunctiveFacetsRefinements[dfacet].indexOf(refinementValue) > -1) {\n              self.disjunctiveFacets[position].data[refinementValue] = 0;\n            }\n          });\n        }\n      }\n    });\n    nextDisjunctiveResult++;\n  });\n\n  // if we have some root level values for hierarchical facets, merge them\n  state.getRefinedHierarchicalFacets().forEach(function(refinedFacet) {\n    var hierarchicalFacet = state.getHierarchicalFacetByName(refinedFacet);\n    var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n\n    var currentRefinement = state.getHierarchicalRefinement(refinedFacet);\n    // if we are already at a root refinement (or no refinement at all), there is no\n    // root level values request\n    if (currentRefinement.length === 0 || currentRefinement[0].split(separator).length < 2) {\n      return;\n    }\n\n    var result = results[nextDisjunctiveResult];\n    var facets = result && result.facets\n      ? result.facets\n      : {};\n    Object.keys(facets).forEach(function(dfacet) {\n      var facetResults = facets[dfacet];\n      var position = findIndex(state.hierarchicalFacets, function(f) {\n        return f.name === hierarchicalFacet.name;\n      });\n      var attributeIndex = findIndex(self.hierarchicalFacets[position], function(f) {\n        return f.attribute === dfacet;\n      });\n\n      // previous refinements and no results so not able to find it\n      if (attributeIndex === -1) {\n        return;\n      }\n\n      // when we always get root levels, if the hits refinement is `beers > IPA` (count: 5),\n      // then the disjunctive values will be `beers` (count: 100),\n      // but we do not want to display\n      //   | beers (100)\n      //     > IPA (5)\n      // We want\n      //   | beers (5)\n      //     > IPA (5)\n      var defaultData = {};\n\n      if (currentRefinement.length > 0) {\n        var root = currentRefinement[0].split(separator)[0];\n        defaultData[root] = self.hierarchicalFacets[position][attributeIndex].data[root];\n      }\n\n      self.hierarchicalFacets[position][attributeIndex].data = defaultsPure(\n        defaultData,\n        facetResults,\n        self.hierarchicalFacets[position][attributeIndex].data\n      );\n    });\n\n    nextDisjunctiveResult++;\n  });\n\n  // add the excludes\n  Object.keys(state.facetsExcludes).forEach(function(facetName) {\n    var excludes = state.facetsExcludes[facetName];\n    var position = facetsIndices[facetName];\n\n    self.facets[position] = {\n      name: facetName,\n      data: mainSubResponse.facets[facetName],\n      exhaustive: mainSubResponse.exhaustiveFacetsCount\n    };\n    excludes.forEach(function(facetValue) {\n      self.facets[position] = self.facets[position] || {name: facetName};\n      self.facets[position].data = self.facets[position].data || {};\n      self.facets[position].data[facetValue] = 0;\n    });\n  });\n\n  /**\n   * @type {Array}\n   */\n  this.hierarchicalFacets = this.hierarchicalFacets.map(generateHierarchicalTree(state));\n\n  /**\n   * @type {Array}\n   */\n  this.facets = compact(this.facets);\n  /**\n   * @type {Array}\n   */\n  this.disjunctiveFacets = compact(this.disjunctiveFacets);\n\n  this._state = state;\n}\n\n/**\n * Get a facet object with its name\n * @deprecated\n * @param {string} name name of the faceted attribute\n * @return {SearchResults.Facet} the facet object\n */\nSearchResults.prototype.getFacetByName = function(name) {\n  function predicate(facet) {\n    return facet.name === name;\n  }\n\n  return find(this.facets, predicate) ||\n    find(this.disjunctiveFacets, predicate) ||\n    find(this.hierarchicalFacets, predicate);\n};\n\n/**\n * Get the facet values of a specified attribute from a SearchResults object.\n * @private\n * @param {SearchResults} results the search results to search in\n * @param {string} attribute name of the faceted attribute to search for\n * @return {array|object} facet values. For the hierarchical facets it is an object.\n */\nfunction extractNormalizedFacetValues(results, attribute) {\n  function predicate(facet) {\n    return facet.name === attribute;\n  }\n\n  if (results._state.isConjunctiveFacet(attribute)) {\n    var facet = find(results.facets, predicate);\n    if (!facet) return [];\n\n    return Object.keys(facet.data).map(function(name) {\n      return {\n        name: name,\n        count: facet.data[name],\n        isRefined: results._state.isFacetRefined(attribute, name),\n        isExcluded: results._state.isExcludeRefined(attribute, name)\n      };\n    });\n  } else if (results._state.isDisjunctiveFacet(attribute)) {\n    var disjunctiveFacet = find(results.disjunctiveFacets, predicate);\n    if (!disjunctiveFacet) return [];\n\n    return Object.keys(disjunctiveFacet.data).map(function(name) {\n      return {\n        name: name,\n        count: disjunctiveFacet.data[name],\n        isRefined: results._state.isDisjunctiveFacetRefined(attribute, name)\n      };\n    });\n  } else if (results._state.isHierarchicalFacet(attribute)) {\n    return find(results.hierarchicalFacets, predicate);\n  }\n}\n\n/**\n * Sort nodes of a hierarchical facet results\n * @private\n * @param {HierarchicalFacet} node node to upon which we want to apply the sort\n */\nfunction recSort(sortFn, node) {\n  if (!node.data || node.data.length === 0) {\n    return node;\n  }\n\n  var children = node.data.map(function(childNode) {\n    return recSort(sortFn, childNode);\n  });\n  var sortedChildren = sortFn(children);\n  var newNode = merge({}, node, {data: sortedChildren});\n  return newNode;\n}\n\nSearchResults.DEFAULT_SORT = ['isRefined:desc', 'count:desc', 'name:asc'];\n\nfunction vanillaSortFn(order, data) {\n  return data.sort(order);\n}\n\n/**\n * Get a the list of values for a given facet attribute. Those values are sorted\n * refinement first, descending count (bigger value on top), and name ascending\n * (alphabetical order). The sort formula can overridden using either string based\n * predicates or a function.\n *\n * This method will return all the values returned by the Algolia engine plus all\n * the values already refined. This means that it can happen that the\n * `maxValuesPerFacet` [configuration](https://www.algolia.com/doc/rest-api/search#param-maxValuesPerFacet)\n * might not be respected if you have facet values that are already refined.\n * @param {string} attribute attribute name\n * @param {object} opts configuration options.\n * @param {Array.<string> | function} opts.sortBy\n * When using strings, it consists of\n * the name of the [FacetValue](#SearchResults.FacetValue) or the\n * [HierarchicalFacet](#SearchResults.HierarchicalFacet) attributes with the\n * order (`asc` or `desc`). For example to order the value by count, the\n * argument would be `['count:asc']`.\n *\n * If only the attribute name is specified, the ordering defaults to the one\n * specified in the default value for this attribute.\n *\n * When not specified, the order is\n * ascending.  This parameter can also be a function which takes two facet\n * values and should return a number, 0 if equal, 1 if the first argument is\n * bigger or -1 otherwise.\n *\n * The default value for this attribute `['isRefined:desc', 'count:desc', 'name:asc']`\n * @return {FacetValue[]|HierarchicalFacet|undefined} depending on the type of facet of\n * the attribute requested (hierarchical, disjunctive or conjunctive)\n * @example\n * helper.on('result', function(event){\n *   //get values ordered only by name ascending using the string predicate\n *   event.results.getFacetValues('city', {sortBy: ['name:asc']});\n *   //get values  ordered only by count ascending using a function\n *   event.results.getFacetValues('city', {\n *     // this is equivalent to ['count:asc']\n *     sortBy: function(a, b) {\n *       if (a.count === b.count) return 0;\n *       if (a.count > b.count)   return 1;\n *       if (b.count > a.count)   return -1;\n *     }\n *   });\n * });\n */\nSearchResults.prototype.getFacetValues = function(attribute, opts) {\n  var facetValues = extractNormalizedFacetValues(this, attribute);\n  if (!facetValues) {\n    return undefined;\n  }\n\n  var options = defaultsPure({}, opts, {sortBy: SearchResults.DEFAULT_SORT});\n\n  if (Array.isArray(options.sortBy)) {\n    var order = formatSort(options.sortBy, SearchResults.DEFAULT_SORT);\n    if (Array.isArray(facetValues)) {\n      return orderBy(facetValues, order[0], order[1]);\n    }\n    // If facetValues is not an array, it's an object thus a hierarchical facet object\n    return recSort(function(hierarchicalFacetValues) {\n      return orderBy(hierarchicalFacetValues, order[0], order[1]);\n    }, facetValues);\n  } else if (typeof options.sortBy === 'function') {\n    if (Array.isArray(facetValues)) {\n      return facetValues.sort(options.sortBy);\n    }\n    // If facetValues is not an array, it's an object thus a hierarchical facet object\n    return recSort(function(data) {\n      return vanillaSortFn(options.sortBy, data);\n    }, facetValues);\n  }\n  throw new Error(\n    'options.sortBy is optional but if defined it must be ' +\n    'either an array of string (predicates) or a sorting function'\n  );\n};\n\n/**\n * Returns the facet stats if attribute is defined and the facet contains some.\n * Otherwise returns undefined.\n * @param {string} attribute name of the faceted attribute\n * @return {object} The stats of the facet\n */\nSearchResults.prototype.getFacetStats = function(attribute) {\n  if (this._state.isConjunctiveFacet(attribute)) {\n    return getFacetStatsIfAvailable(this.facets, attribute);\n  } else if (this._state.isDisjunctiveFacet(attribute)) {\n    return getFacetStatsIfAvailable(this.disjunctiveFacets, attribute);\n  }\n\n  return undefined;\n};\n\n/**\n * @typedef {Object} FacetListItem\n * @property {string} name\n */\n\n/**\n * @param {FacetListItem[]} facetList (has more items, but enough for here)\n * @param {string} facetName\n */\nfunction getFacetStatsIfAvailable(facetList, facetName) {\n  var data = find(facetList, function(facet) {\n    return facet.name === facetName;\n  });\n  return data && data.stats;\n}\n\n/**\n * Returns all refinements for all filters + tags. It also provides\n * additional information: count and exhaustiveness for each filter.\n *\n * See the [refinement type](#Refinement) for an exhaustive view of the available\n * data.\n *\n * Note that for a numeric refinement, results are grouped per operator, this\n * means that it will return responses for operators which are empty.\n *\n * @return {Array.<Refinement>} all the refinements\n */\nSearchResults.prototype.getRefinements = function() {\n  var state = this._state;\n  var results = this;\n  var res = [];\n\n  Object.keys(state.facetsRefinements).forEach(function(attributeName) {\n    state.facetsRefinements[attributeName].forEach(function(name) {\n      res.push(getRefinement(state, 'facet', attributeName, name, results.facets));\n    });\n  });\n\n  Object.keys(state.facetsExcludes).forEach(function(attributeName) {\n    state.facetsExcludes[attributeName].forEach(function(name) {\n      res.push(getRefinement(state, 'exclude', attributeName, name, results.facets));\n    });\n  });\n\n  Object.keys(state.disjunctiveFacetsRefinements).forEach(function(attributeName) {\n    state.disjunctiveFacetsRefinements[attributeName].forEach(function(name) {\n      res.push(getRefinement(state, 'disjunctive', attributeName, name, results.disjunctiveFacets));\n    });\n  });\n\n  Object.keys(state.hierarchicalFacetsRefinements).forEach(function(attributeName) {\n    state.hierarchicalFacetsRefinements[attributeName].forEach(function(name) {\n      res.push(getHierarchicalRefinement(state, attributeName, name, results.hierarchicalFacets));\n    });\n  });\n\n\n  Object.keys(state.numericRefinements).forEach(function(attributeName) {\n    var operators = state.numericRefinements[attributeName];\n    Object.keys(operators).forEach(function(operator) {\n      operators[operator].forEach(function(value) {\n        res.push({\n          type: 'numeric',\n          attributeName: attributeName,\n          name: value,\n          numericValue: value,\n          operator: operator\n        });\n      });\n    });\n  });\n\n  state.tagRefinements.forEach(function(name) {\n    res.push({type: 'tag', attributeName: '_tags', name: name});\n  });\n\n  return res;\n};\n\n/**\n * @typedef {Object} Facet\n * @property {string} name\n * @property {Object} data\n * @property {boolean} exhaustive\n */\n\n/**\n * @param {*} state\n * @param {*} type\n * @param {string} attributeName\n * @param {*} name\n * @param {Facet[]} resultsFacets\n */\nfunction getRefinement(state, type, attributeName, name, resultsFacets) {\n  var facet = find(resultsFacets, function(f) {\n    return f.name === attributeName;\n  });\n  var count = facet && facet.data && facet.data[name] ? facet.data[name] : 0;\n  var exhaustive = (facet && facet.exhaustive) || false;\n\n  return {\n    type: type,\n    attributeName: attributeName,\n    name: name,\n    count: count,\n    exhaustive: exhaustive\n  };\n}\n\n/**\n * @param {*} state\n * @param {string} attributeName\n * @param {*} name\n * @param {Facet[]} resultsFacets\n */\nfunction getHierarchicalRefinement(state, attributeName, name, resultsFacets) {\n  var facetDeclaration = state.getHierarchicalFacetByName(attributeName);\n  var separator = state._getHierarchicalFacetSeparator(facetDeclaration);\n  var split = name.split(separator);\n  var rootFacet = find(resultsFacets, function(facet) {\n    return facet.name === attributeName;\n  });\n\n  var facet = split.reduce(function(intermediateFacet, part) {\n    var newFacet =\n      intermediateFacet && find(intermediateFacet.data, function(f) {\n        return f.name === part;\n      });\n    return newFacet !== undefined ? newFacet : intermediateFacet;\n  }, rootFacet);\n\n  var count = (facet && facet.count) || 0;\n  var exhaustive = (facet && facet.exhaustive) || false;\n  var path = (facet && facet.path) || '';\n\n  return {\n    type: 'hierarchical',\n    attributeName: attributeName,\n    name: path,\n    count: count,\n    exhaustive: exhaustive\n  };\n}\n\nmodule.exports = SearchResults;\n"]},"metadata":{},"sourceType":"script"}