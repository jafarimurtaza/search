{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport isEqual from 'react-fast-compare';\nimport createConnector from '../core/createConnector';\nimport { getCurrentRefinementValue, refineValue, getResults } from '../core/indexUtils';\nimport { addAbsolutePositions, addQueryID } from '../core/utils';\n\nfunction getId() {\n  return 'page';\n}\n\nfunction getCurrentRefinement(props, searchState, context) {\n  var id = getId();\n  var page = 1;\n  var currentRefinement = getCurrentRefinementValue(props, searchState, context, id, page);\n\n  if (typeof currentRefinement === 'string') {\n    return parseInt(currentRefinement, 10);\n  }\n\n  return currentRefinement;\n}\n\nfunction getStateWithoutPage(state) {\n  var _ref = state || {},\n      page = _ref.page,\n      rest = _objectWithoutProperties(_ref, [\"page\"]);\n\n  return rest;\n}\n\nfunction getInMemoryCache() {\n  var cachedHits = undefined;\n  var cachedState = undefined;\n  return {\n    read: function read(_ref2) {\n      var state = _ref2.state;\n      return isEqual(cachedState, getStateWithoutPage(state)) ? cachedHits : null;\n    },\n    write: function write(_ref3) {\n      var state = _ref3.state,\n          hits = _ref3.hits;\n      cachedState = getStateWithoutPage(state);\n      cachedHits = hits;\n    }\n  };\n}\n\nfunction extractHitsFromCachedHits(cachedHits) {\n  return Object.keys(cachedHits).map(Number).sort(function (a, b) {\n    return a - b;\n  }).reduce(function (acc, page) {\n    return acc.concat(cachedHits[page]);\n  }, []);\n}\n/**\n * InfiniteHits connector provides the logic to create connected\n * components that will render an continuous list of results retrieved from\n * Algolia. This connector provides a function to load more results.\n * @name connectInfiniteHits\n * @kind connector\n * @providedPropType {array.<object>} hits - the records that matched the search state\n * @providedPropType {boolean} hasMore - indicates if there are more pages to load\n * @providedPropType {function} refine - call to load more results\n */\n\n\nexport default createConnector({\n  displayName: 'AlgoliaInfiniteHits',\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var _this = this;\n\n    var results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    this._prevState = this._prevState || {};\n    var cache = props.cache || getInMemoryCache();\n\n    if (this._cachedHits === undefined) {\n      this._cachedHits = cache.read({\n        state: searchState\n      }) || {};\n    }\n\n    if (!results) {\n      return {\n        hits: extractHitsFromCachedHits(this._cachedHits),\n        hasPrevious: false,\n        hasMore: false,\n        refine: function refine() {},\n        refinePrevious: function refinePrevious() {},\n        refineNext: function refineNext() {}\n      };\n    }\n\n    var page = results.page,\n        hits = results.hits,\n        hitsPerPage = results.hitsPerPage,\n        nbPages = results.nbPages,\n        _results$_state = results._state;\n    _results$_state = _results$_state === void 0 ? {} : _results$_state;\n\n    var p = _results$_state.page,\n        currentState = _objectWithoutProperties(_results$_state, [\"page\"]);\n\n    var hitsWithPositions = addAbsolutePositions(hits, hitsPerPage, page);\n    var hitsWithPositionsAndQueryID = addQueryID(hitsWithPositions, results.queryID);\n\n    if (!isEqual(currentState, this._prevState)) {\n      this._cachedHits = cache.read({\n        state: searchState\n      }) || {};\n    }\n\n    if (this._cachedHits[page] === undefined) {\n      this._cachedHits[page] = hitsWithPositionsAndQueryID;\n      cache.write({\n        state: searchState,\n        hits: this._cachedHits\n      });\n    }\n\n    this._prevState = currentState;\n    /*\n      Math.min() and Math.max() returns Infinity or -Infinity when no argument is given.\n      But there is always something in this point because of `this._cachedHits[page]`.\n    */\n\n    var firstReceivedPage = Math.min.apply(Math, _toConsumableArray(Object.keys(this._cachedHits).map(Number)));\n    var lastReceivedPage = Math.max.apply(Math, _toConsumableArray(Object.keys(this._cachedHits).map(Number)));\n    var hasPrevious = firstReceivedPage > 0;\n    var lastPageIndex = nbPages - 1;\n    var hasMore = lastReceivedPage < lastPageIndex;\n\n    var refinePrevious = function refinePrevious(event) {\n      return _this.refine(event, firstReceivedPage - 1);\n    };\n\n    var refineNext = function refineNext(event) {\n      return _this.refine(event, lastReceivedPage + 1);\n    };\n\n    return {\n      hits: extractHitsFromCachedHits(this._cachedHits),\n      hasPrevious: hasPrevious,\n      hasMore: hasMore,\n      refinePrevious: refinePrevious,\n      refineNext: refineNext\n    };\n  },\n  getSearchParameters: function getSearchParameters(searchParameters, props, searchState) {\n    return searchParameters.setQueryParameters({\n      page: getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      }) - 1\n    });\n  },\n  refine: function refine(props, searchState, event, index) {\n    var pages = Object.keys(this._cachedHits || {}).map(Number);\n    var lastReceivedPage = pages.length === 0 ? undefined : Math.max.apply(Math, _toConsumableArray(pages)); // If there is no key in `this._cachedHits`,\n    // then `lastReceivedPage` should be `undefined`.\n\n    if (index === undefined && lastReceivedPage !== undefined) {\n      index = lastReceivedPage + 1;\n    } else if (index === undefined) {\n      index = getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      });\n    }\n\n    var id = getId();\n\n    var nextValue = _defineProperty({}, id, index + 1);\n\n    var resetPage = false;\n    return refineValue(searchState, nextValue, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }, resetPage);\n  }\n});","map":{"version":3,"sources":["C:/Users/Murtaza Jafari/Desktop/product-search/product/searcbox/node_modules/react-instantsearch-core/dist/es/connectors/connectInfiniteHits.js"],"names":["_defineProperty","_toConsumableArray","_objectWithoutProperties","isEqual","createConnector","getCurrentRefinementValue","refineValue","getResults","addAbsolutePositions","addQueryID","getId","getCurrentRefinement","props","searchState","context","id","page","currentRefinement","parseInt","getStateWithoutPage","state","_ref","rest","getInMemoryCache","cachedHits","undefined","cachedState","read","_ref2","write","_ref3","hits","extractHitsFromCachedHits","Object","keys","map","Number","sort","a","b","reduce","acc","concat","displayName","getProvidedProps","searchResults","_this","results","ais","contextValue","multiIndexContext","indexContextValue","_prevState","cache","_cachedHits","hasPrevious","hasMore","refine","refinePrevious","refineNext","hitsPerPage","nbPages","_results$_state","_state","p","currentState","hitsWithPositions","hitsWithPositionsAndQueryID","queryID","firstReceivedPage","Math","min","apply","lastReceivedPage","max","lastPageIndex","event","getSearchParameters","searchParameters","setQueryParameters","index","pages","length","nextValue","resetPage"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport isEqual from 'react-fast-compare';\nimport createConnector from '../core/createConnector';\nimport { getCurrentRefinementValue, refineValue, getResults } from '../core/indexUtils';\nimport { addAbsolutePositions, addQueryID } from '../core/utils';\n\nfunction getId() {\n  return 'page';\n}\n\nfunction getCurrentRefinement(props, searchState, context) {\n  var id = getId();\n  var page = 1;\n  var currentRefinement = getCurrentRefinementValue(props, searchState, context, id, page);\n\n  if (typeof currentRefinement === 'string') {\n    return parseInt(currentRefinement, 10);\n  }\n\n  return currentRefinement;\n}\n\nfunction getStateWithoutPage(state) {\n  var _ref = state || {},\n      page = _ref.page,\n      rest = _objectWithoutProperties(_ref, [\"page\"]);\n\n  return rest;\n}\n\nfunction getInMemoryCache() {\n  var cachedHits = undefined;\n  var cachedState = undefined;\n  return {\n    read: function read(_ref2) {\n      var state = _ref2.state;\n      return isEqual(cachedState, getStateWithoutPage(state)) ? cachedHits : null;\n    },\n    write: function write(_ref3) {\n      var state = _ref3.state,\n          hits = _ref3.hits;\n      cachedState = getStateWithoutPage(state);\n      cachedHits = hits;\n    }\n  };\n}\n\nfunction extractHitsFromCachedHits(cachedHits) {\n  return Object.keys(cachedHits).map(Number).sort(function (a, b) {\n    return a - b;\n  }).reduce(function (acc, page) {\n    return acc.concat(cachedHits[page]);\n  }, []);\n}\n/**\n * InfiniteHits connector provides the logic to create connected\n * components that will render an continuous list of results retrieved from\n * Algolia. This connector provides a function to load more results.\n * @name connectInfiniteHits\n * @kind connector\n * @providedPropType {array.<object>} hits - the records that matched the search state\n * @providedPropType {boolean} hasMore - indicates if there are more pages to load\n * @providedPropType {function} refine - call to load more results\n */\n\n\nexport default createConnector({\n  displayName: 'AlgoliaInfiniteHits',\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var _this = this;\n\n    var results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    this._prevState = this._prevState || {};\n    var cache = props.cache || getInMemoryCache();\n\n    if (this._cachedHits === undefined) {\n      this._cachedHits = cache.read({\n        state: searchState\n      }) || {};\n    }\n\n    if (!results) {\n      return {\n        hits: extractHitsFromCachedHits(this._cachedHits),\n        hasPrevious: false,\n        hasMore: false,\n        refine: function refine() {},\n        refinePrevious: function refinePrevious() {},\n        refineNext: function refineNext() {}\n      };\n    }\n\n    var page = results.page,\n        hits = results.hits,\n        hitsPerPage = results.hitsPerPage,\n        nbPages = results.nbPages,\n        _results$_state = results._state;\n    _results$_state = _results$_state === void 0 ? {} : _results$_state;\n\n    var p = _results$_state.page,\n        currentState = _objectWithoutProperties(_results$_state, [\"page\"]);\n\n    var hitsWithPositions = addAbsolutePositions(hits, hitsPerPage, page);\n    var hitsWithPositionsAndQueryID = addQueryID(hitsWithPositions, results.queryID);\n\n    if (!isEqual(currentState, this._prevState)) {\n      this._cachedHits = cache.read({\n        state: searchState\n      }) || {};\n    }\n\n    if (this._cachedHits[page] === undefined) {\n      this._cachedHits[page] = hitsWithPositionsAndQueryID;\n      cache.write({\n        state: searchState,\n        hits: this._cachedHits\n      });\n    }\n\n    this._prevState = currentState;\n    /*\n      Math.min() and Math.max() returns Infinity or -Infinity when no argument is given.\n      But there is always something in this point because of `this._cachedHits[page]`.\n    */\n\n    var firstReceivedPage = Math.min.apply(Math, _toConsumableArray(Object.keys(this._cachedHits).map(Number)));\n    var lastReceivedPage = Math.max.apply(Math, _toConsumableArray(Object.keys(this._cachedHits).map(Number)));\n    var hasPrevious = firstReceivedPage > 0;\n    var lastPageIndex = nbPages - 1;\n    var hasMore = lastReceivedPage < lastPageIndex;\n\n    var refinePrevious = function refinePrevious(event) {\n      return _this.refine(event, firstReceivedPage - 1);\n    };\n\n    var refineNext = function refineNext(event) {\n      return _this.refine(event, lastReceivedPage + 1);\n    };\n\n    return {\n      hits: extractHitsFromCachedHits(this._cachedHits),\n      hasPrevious: hasPrevious,\n      hasMore: hasMore,\n      refinePrevious: refinePrevious,\n      refineNext: refineNext\n    };\n  },\n  getSearchParameters: function getSearchParameters(searchParameters, props, searchState) {\n    return searchParameters.setQueryParameters({\n      page: getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      }) - 1\n    });\n  },\n  refine: function refine(props, searchState, event, index) {\n    var pages = Object.keys(this._cachedHits || {}).map(Number);\n    var lastReceivedPage = pages.length === 0 ? undefined : Math.max.apply(Math, _toConsumableArray(pages)); // If there is no key in `this._cachedHits`,\n    // then `lastReceivedPage` should be `undefined`.\n\n    if (index === undefined && lastReceivedPage !== undefined) {\n      index = lastReceivedPage + 1;\n    } else if (index === undefined) {\n      index = getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      });\n    }\n\n    var id = getId();\n\n    var nextValue = _defineProperty({}, id, index + 1);\n\n    var resetPage = false;\n    return refineValue(searchState, nextValue, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }, resetPage);\n  }\n});"]},"metadata":{},"sourceType":"module"}