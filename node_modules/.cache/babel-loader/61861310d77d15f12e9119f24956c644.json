{"ast":null,"code":"import PropTypes from 'prop-types';\nimport createConnector from '../core/createConnector';\nimport { getCurrentRefinementValue, hasMultipleIndices, getIndexId } from '../core/indexUtils';\nimport { shallowEqual, omit } from '../core/utils';\n/**\n * connectScrollTo connector provides the logic to build a widget that will\n * let the page scroll to a certain point.\n * @name connectScrollTo\n * @kind connector\n * @propType {string} [scrollOn=\"page\"] - Widget searchState key on which to listen for changes, default to the pagination widget.\n * @providedPropType {any} value - the current refinement applied to the widget listened by scrollTo\n * @providedPropType {boolean} hasNotChanged - indicates whether the refinement came from the scrollOn argument (for instance page by default)\n */\n\nexport default createConnector({\n  displayName: 'AlgoliaScrollTo',\n  propTypes: {\n    scrollOn: PropTypes.string\n  },\n  defaultProps: {\n    scrollOn: 'page'\n  },\n  getProvidedProps: function getProvidedProps(props, searchState) {\n    var id = props.scrollOn;\n    var value = getCurrentRefinementValue(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }, id, null);\n\n    if (!this._prevSearchState) {\n      this._prevSearchState = {};\n    } // Get the subpart of the state that interest us\n\n\n    if (hasMultipleIndices({\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    })) {\n      searchState = searchState.indices ? searchState.indices[getIndexId({\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      })] : {};\n    } // if there is a change in the app that has been triggered by another element\n    // than \"props.scrollOn (id) or the Configure widget, we need to keep track of\n    // the search state to know if there's a change in the app that was not triggered\n    // by the props.scrollOn (id) or the Configure widget. This is useful when\n    // using ScrollTo in combination of Pagination. As pagination can be change\n    // by every widget, we want to scroll only if it cames from the pagination\n    // widget itself. We also remove the configure key from the search state to\n    // do this comparison because for now configure values are not present in the\n    // search state before a first refinement has been made and will false the results.\n    // See: https://github.com/algolia/react-instantsearch/issues/164\n\n\n    var cleanedSearchState = omit(searchState, ['configure', id]);\n    var hasNotChanged = shallowEqual(this._prevSearchState, cleanedSearchState);\n    this._prevSearchState = cleanedSearchState;\n    return {\n      value: value,\n      hasNotChanged: hasNotChanged\n    };\n  }\n});","map":{"version":3,"sources":["C:/Users/Murtaza Jafari/Desktop/product-search/product/searcbox/node_modules/react-instantsearch-core/dist/es/connectors/connectScrollTo.js"],"names":["PropTypes","createConnector","getCurrentRefinementValue","hasMultipleIndices","getIndexId","shallowEqual","omit","displayName","propTypes","scrollOn","string","defaultProps","getProvidedProps","props","searchState","id","value","ais","contextValue","multiIndexContext","indexContextValue","_prevSearchState","indices","cleanedSearchState","hasNotChanged"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,YAAtB;AACA,OAAOC,eAAP,MAA4B,yBAA5B;AACA,SAASC,yBAAT,EAAoCC,kBAApC,EAAwDC,UAAxD,QAA0E,oBAA1E;AACA,SAASC,YAAT,EAAuBC,IAAvB,QAAmC,eAAnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAeL,eAAe,CAAC;AAC7BM,EAAAA,WAAW,EAAE,iBADgB;AAE7BC,EAAAA,SAAS,EAAE;AACTC,IAAAA,QAAQ,EAAET,SAAS,CAACU;AADX,GAFkB;AAK7BC,EAAAA,YAAY,EAAE;AACZF,IAAAA,QAAQ,EAAE;AADE,GALe;AAQ7BG,EAAAA,gBAAgB,EAAE,SAASA,gBAAT,CAA0BC,KAA1B,EAAiCC,WAAjC,EAA8C;AAC9D,QAAIC,EAAE,GAAGF,KAAK,CAACJ,QAAf;AACA,QAAIO,KAAK,GAAGd,yBAAyB,CAACW,KAAD,EAAQC,WAAR,EAAqB;AACxDG,MAAAA,GAAG,EAAEJ,KAAK,CAACK,YAD6C;AAExDC,MAAAA,iBAAiB,EAAEN,KAAK,CAACO;AAF+B,KAArB,EAGlCL,EAHkC,EAG9B,IAH8B,CAArC;;AAKA,QAAI,CAAC,KAAKM,gBAAV,EAA4B;AAC1B,WAAKA,gBAAL,GAAwB,EAAxB;AACD,KAT6D,CAS5D;;;AAGF,QAAIlB,kBAAkB,CAAC;AACrBc,MAAAA,GAAG,EAAEJ,KAAK,CAACK,YADU;AAErBC,MAAAA,iBAAiB,EAAEN,KAAK,CAACO;AAFJ,KAAD,CAAtB,EAGI;AACFN,MAAAA,WAAW,GAAGA,WAAW,CAACQ,OAAZ,GAAsBR,WAAW,CAACQ,OAAZ,CAAoBlB,UAAU,CAAC;AACjEa,QAAAA,GAAG,EAAEJ,KAAK,CAACK,YADsD;AAEjEC,QAAAA,iBAAiB,EAAEN,KAAK,CAACO;AAFwC,OAAD,CAA9B,CAAtB,GAGR,EAHN;AAID,KApB6D,CAoB5D;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,QAAIG,kBAAkB,GAAGjB,IAAI,CAACQ,WAAD,EAAc,CAAC,WAAD,EAAcC,EAAd,CAAd,CAA7B;AACA,QAAIS,aAAa,GAAGnB,YAAY,CAAC,KAAKgB,gBAAN,EAAwBE,kBAAxB,CAAhC;AACA,SAAKF,gBAAL,GAAwBE,kBAAxB;AACA,WAAO;AACLP,MAAAA,KAAK,EAAEA,KADF;AAELQ,MAAAA,aAAa,EAAEA;AAFV,KAAP;AAID;AA/C4B,CAAD,CAA9B","sourcesContent":["import PropTypes from 'prop-types';\nimport createConnector from '../core/createConnector';\nimport { getCurrentRefinementValue, hasMultipleIndices, getIndexId } from '../core/indexUtils';\nimport { shallowEqual, omit } from '../core/utils';\n/**\n * connectScrollTo connector provides the logic to build a widget that will\n * let the page scroll to a certain point.\n * @name connectScrollTo\n * @kind connector\n * @propType {string} [scrollOn=\"page\"] - Widget searchState key on which to listen for changes, default to the pagination widget.\n * @providedPropType {any} value - the current refinement applied to the widget listened by scrollTo\n * @providedPropType {boolean} hasNotChanged - indicates whether the refinement came from the scrollOn argument (for instance page by default)\n */\n\nexport default createConnector({\n  displayName: 'AlgoliaScrollTo',\n  propTypes: {\n    scrollOn: PropTypes.string\n  },\n  defaultProps: {\n    scrollOn: 'page'\n  },\n  getProvidedProps: function getProvidedProps(props, searchState) {\n    var id = props.scrollOn;\n    var value = getCurrentRefinementValue(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }, id, null);\n\n    if (!this._prevSearchState) {\n      this._prevSearchState = {};\n    } // Get the subpart of the state that interest us\n\n\n    if (hasMultipleIndices({\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    })) {\n      searchState = searchState.indices ? searchState.indices[getIndexId({\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      })] : {};\n    } // if there is a change in the app that has been triggered by another element\n    // than \"props.scrollOn (id) or the Configure widget, we need to keep track of\n    // the search state to know if there's a change in the app that was not triggered\n    // by the props.scrollOn (id) or the Configure widget. This is useful when\n    // using ScrollTo in combination of Pagination. As pagination can be change\n    // by every widget, we want to scroll only if it cames from the pagination\n    // widget itself. We also remove the configure key from the search state to\n    // do this comparison because for now configure values are not present in the\n    // search state before a first refinement has been made and will false the results.\n    // See: https://github.com/algolia/react-instantsearch/issues/164\n\n\n    var cleanedSearchState = omit(searchState, ['configure', id]);\n    var hasNotChanged = shallowEqual(this._prevSearchState, cleanedSearchState);\n    this._prevSearchState = cleanedSearchState;\n    return {\n      value: value,\n      hasNotChanged: hasNotChanged\n    };\n  }\n});"]},"metadata":{},"sourceType":"module"}