{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread\";\nimport PropTypes from 'prop-types';\nimport createConnector from '../core/createConnector';\n/**\n * connectCurrentRefinements connector provides the logic to build a widget that will\n * give the user the ability to remove all or some of the filters that were\n * set.\n * @name connectCurrentRefinements\n * @kind connector\n * @propType {function} [transformItems] - Function to modify the items being displayed, e.g. for filtering or sorting them. Takes an items as parameter and expects it back in return.\n * @propType {function} [clearsQuery=false] - Pass true to also clear the search query\n * @providedPropType {function} refine - a function to remove a single filter\n * @providedPropType {array.<{label: string, attribute: string, currentRefinement: string || object, items: array, value: function}>} items - all the filters, the `value` is to pass to the `refine` function for removing all currentrefinements, `label` is for the display. When existing several refinements for the same atribute name, then you get a nested `items` object that contains a `label` and a `value` function to use to remove a single filter. `attribute` and `currentRefinement` are metadata containing row values.\n * @providedPropType {string} query - the search query\n */\n\nexport default createConnector({\n  displayName: 'AlgoliaCurrentRefinements',\n  propTypes: {\n    transformItems: PropTypes.func\n  },\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults, metadata) {\n    var items = metadata.reduce(function (res, meta) {\n      if (typeof meta.items !== 'undefined') {\n        if (!props.clearsQuery && meta.id === 'query') {\n          return res;\n        } else {\n          if (props.clearsQuery && meta.id === 'query' && meta.items[0].currentRefinement === '') {\n            return res;\n          }\n\n          return res.concat(meta.items.map(function (item) {\n            return _objectSpread({}, item, {\n              id: meta.id,\n              index: meta.index\n            });\n          }));\n        }\n      }\n\n      return res;\n    }, []);\n    var transformedItems = props.transformItems ? props.transformItems(items) : items;\n    return {\n      items: transformedItems,\n      canRefine: transformedItems.length > 0\n    };\n  },\n  refine: function refine(props, searchState, items) {\n    // `value` corresponds to our internal clear function computed in each connector metadata.\n    var refinementsToClear = items instanceof Array ? items.map(function (item) {\n      return item.value;\n    }) : [items];\n    return refinementsToClear.reduce(function (res, clear) {\n      return clear(res);\n    }, searchState);\n  }\n});","map":{"version":3,"sources":["C:/Users/Murtaza Jafari/Desktop/product-search/product/searcbox/node_modules/react-instantsearch-core/dist/es/connectors/connectCurrentRefinements.js"],"names":["_objectSpread","PropTypes","createConnector","displayName","propTypes","transformItems","func","getProvidedProps","props","searchState","searchResults","metadata","items","reduce","res","meta","clearsQuery","id","currentRefinement","concat","map","item","index","transformedItems","canRefine","length","refine","refinementsToClear","Array","value","clear"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,yCAA1B;AACA,OAAOC,SAAP,MAAsB,YAAtB;AACA,OAAOC,eAAP,MAA4B,yBAA5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAeA,eAAe,CAAC;AAC7BC,EAAAA,WAAW,EAAE,2BADgB;AAE7BC,EAAAA,SAAS,EAAE;AACTC,IAAAA,cAAc,EAAEJ,SAAS,CAACK;AADjB,GAFkB;AAK7BC,EAAAA,gBAAgB,EAAE,SAASA,gBAAT,CAA0BC,KAA1B,EAAiCC,WAAjC,EAA8CC,aAA9C,EAA6DC,QAA7D,EAAuE;AACvF,QAAIC,KAAK,GAAGD,QAAQ,CAACE,MAAT,CAAgB,UAAUC,GAAV,EAAeC,IAAf,EAAqB;AAC/C,UAAI,OAAOA,IAAI,CAACH,KAAZ,KAAsB,WAA1B,EAAuC;AACrC,YAAI,CAACJ,KAAK,CAACQ,WAAP,IAAsBD,IAAI,CAACE,EAAL,KAAY,OAAtC,EAA+C;AAC7C,iBAAOH,GAAP;AACD,SAFD,MAEO;AACL,cAAIN,KAAK,CAACQ,WAAN,IAAqBD,IAAI,CAACE,EAAL,KAAY,OAAjC,IAA4CF,IAAI,CAACH,KAAL,CAAW,CAAX,EAAcM,iBAAd,KAAoC,EAApF,EAAwF;AACtF,mBAAOJ,GAAP;AACD;;AAED,iBAAOA,GAAG,CAACK,MAAJ,CAAWJ,IAAI,CAACH,KAAL,CAAWQ,GAAX,CAAe,UAAUC,IAAV,EAAgB;AAC/C,mBAAOrB,aAAa,CAAC,EAAD,EAAKqB,IAAL,EAAW;AAC7BJ,cAAAA,EAAE,EAAEF,IAAI,CAACE,EADoB;AAE7BK,cAAAA,KAAK,EAAEP,IAAI,CAACO;AAFiB,aAAX,CAApB;AAID,WALiB,CAAX,CAAP;AAMD;AACF;;AAED,aAAOR,GAAP;AACD,KAnBW,EAmBT,EAnBS,CAAZ;AAoBA,QAAIS,gBAAgB,GAAGf,KAAK,CAACH,cAAN,GAAuBG,KAAK,CAACH,cAAN,CAAqBO,KAArB,CAAvB,GAAqDA,KAA5E;AACA,WAAO;AACLA,MAAAA,KAAK,EAAEW,gBADF;AAELC,MAAAA,SAAS,EAAED,gBAAgB,CAACE,MAAjB,GAA0B;AAFhC,KAAP;AAID,GA/B4B;AAgC7BC,EAAAA,MAAM,EAAE,SAASA,MAAT,CAAgBlB,KAAhB,EAAuBC,WAAvB,EAAoCG,KAApC,EAA2C;AACjD;AACA,QAAIe,kBAAkB,GAAGf,KAAK,YAAYgB,KAAjB,GAAyBhB,KAAK,CAACQ,GAAN,CAAU,UAAUC,IAAV,EAAgB;AAC1E,aAAOA,IAAI,CAACQ,KAAZ;AACD,KAFiD,CAAzB,GAEpB,CAACjB,KAAD,CAFL;AAGA,WAAOe,kBAAkB,CAACd,MAAnB,CAA0B,UAAUC,GAAV,EAAegB,KAAf,EAAsB;AACrD,aAAOA,KAAK,CAAChB,GAAD,CAAZ;AACD,KAFM,EAEJL,WAFI,CAAP;AAGD;AAxC4B,CAAD,CAA9B","sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread\";\nimport PropTypes from 'prop-types';\nimport createConnector from '../core/createConnector';\n/**\n * connectCurrentRefinements connector provides the logic to build a widget that will\n * give the user the ability to remove all or some of the filters that were\n * set.\n * @name connectCurrentRefinements\n * @kind connector\n * @propType {function} [transformItems] - Function to modify the items being displayed, e.g. for filtering or sorting them. Takes an items as parameter and expects it back in return.\n * @propType {function} [clearsQuery=false] - Pass true to also clear the search query\n * @providedPropType {function} refine - a function to remove a single filter\n * @providedPropType {array.<{label: string, attribute: string, currentRefinement: string || object, items: array, value: function}>} items - all the filters, the `value` is to pass to the `refine` function for removing all currentrefinements, `label` is for the display. When existing several refinements for the same atribute name, then you get a nested `items` object that contains a `label` and a `value` function to use to remove a single filter. `attribute` and `currentRefinement` are metadata containing row values.\n * @providedPropType {string} query - the search query\n */\n\nexport default createConnector({\n  displayName: 'AlgoliaCurrentRefinements',\n  propTypes: {\n    transformItems: PropTypes.func\n  },\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults, metadata) {\n    var items = metadata.reduce(function (res, meta) {\n      if (typeof meta.items !== 'undefined') {\n        if (!props.clearsQuery && meta.id === 'query') {\n          return res;\n        } else {\n          if (props.clearsQuery && meta.id === 'query' && meta.items[0].currentRefinement === '') {\n            return res;\n          }\n\n          return res.concat(meta.items.map(function (item) {\n            return _objectSpread({}, item, {\n              id: meta.id,\n              index: meta.index\n            });\n          }));\n        }\n      }\n\n      return res;\n    }, []);\n    var transformedItems = props.transformItems ? props.transformItems(items) : items;\n    return {\n      items: transformedItems,\n      canRefine: transformedItems.length > 0\n    };\n  },\n  refine: function refine(props, searchState, items) {\n    // `value` corresponds to our internal clear function computed in each connector metadata.\n    var refinementsToClear = items instanceof Array ? items.map(function (item) {\n      return item.value;\n    }) : [items];\n    return refinementsToClear.reduce(function (res, clear) {\n      return clear(res);\n    }, searchState);\n  }\n});"]},"metadata":{},"sourceType":"module"}