{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport createConnector from '../core/createConnector';\nimport { cleanUpValue, refineValue, getCurrentRefinementValue } from '../core/indexUtils';\nimport { addQueryID, addAbsolutePositions } from '../core/utils';\n\nvar getId = function getId() {\n  return 'query';\n};\n\nfunction getCurrentRefinement(props, searchState, context) {\n  var id = getId();\n  var currentRefinement = getCurrentRefinementValue(props, searchState, context, id, '');\n\n  if (currentRefinement) {\n    return currentRefinement;\n  }\n\n  return '';\n}\n\nfunction getHits(searchResults) {\n  if (searchResults.results) {\n    if (searchResults.results.hits && Array.isArray(searchResults.results.hits)) {\n      return addAbsolutePositions(addQueryID(searchResults.results.hits, searchResults.results.queryID), searchResults.results.hitsPerPage, searchResults.results.page);\n    } else {\n      return Object.keys(searchResults.results).reduce(function (hits, index) {\n        return [].concat(_toConsumableArray(hits), [{\n          index: index,\n          hits: addAbsolutePositions(addQueryID(searchResults.results[index].hits, searchResults.results[index].queryID), searchResults.results[index].hitsPerPage, searchResults.results[index].page)\n        }]);\n      }, []);\n    }\n  } else {\n    return [];\n  }\n}\n\nfunction _refine(props, searchState, nextRefinement, context) {\n  var id = getId();\n\n  var nextValue = _defineProperty({}, id, nextRefinement);\n\n  var resetPage = true;\n  return refineValue(searchState, nextValue, context, resetPage);\n}\n\nfunction _cleanUp(props, searchState, context) {\n  return cleanUpValue(searchState, context, getId());\n}\n/**\n * connectAutoComplete connector provides the logic to create connected\n * components that will render the results retrieved from\n * Algolia.\n *\n * To configure the number of hits retrieved, use [HitsPerPage widget](widgets/HitsPerPage.html),\n * [connectHitsPerPage connector](connectors/connectHitsPerPage.html) or pass the hitsPerPage\n * prop to a [Configure](guide/Search_parameters.html) widget.\n * @name connectAutoComplete\n * @kind connector\n * @propType {string} [defaultRefinement] - Provide a default value for the query\n * @providedPropType {array.<object>} hits - the records that matched the search state\n * @providedPropType {function} refine - a function to change the query\n * @providedPropType {string} currentRefinement - the query to search for\n */\n\n\nexport default createConnector({\n  displayName: 'AlgoliaAutoComplete',\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    return {\n      hits: getHits(searchResults),\n      currentRefinement: getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      })\n    };\n  },\n  refine: function refine(props, searchState, nextRefinement) {\n    return _refine(props, searchState, nextRefinement, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return _cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n\n  /**\n   * AutoComplete needs to be considered as a widget to trigger a search,\n   * even if no other widgets are used.\n   *\n   * To be considered as a widget you need either:\n   * - getSearchParameters\n   * - getMetadata\n   * - transitionState\n   *\n   * See: createConnector.tsx\n   */\n  getSearchParameters: function getSearchParameters(searchParameters, props, searchState) {\n    return searchParameters.setQuery(getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }));\n  }\n});","map":{"version":3,"sources":["C:/Users/Murtaza Jafari/Desktop/product-search/product/searcbox/node_modules/react-instantsearch-core/dist/es/connectors/connectAutoComplete.js"],"names":["_defineProperty","_toConsumableArray","createConnector","cleanUpValue","refineValue","getCurrentRefinementValue","addQueryID","addAbsolutePositions","getId","getCurrentRefinement","props","searchState","context","id","currentRefinement","getHits","searchResults","results","hits","Array","isArray","queryID","hitsPerPage","page","Object","keys","reduce","index","concat","_refine","nextRefinement","nextValue","resetPage","_cleanUp","displayName","getProvidedProps","ais","contextValue","multiIndexContext","indexContextValue","refine","cleanUp","getSearchParameters","searchParameters","setQuery"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport createConnector from '../core/createConnector';\nimport { cleanUpValue, refineValue, getCurrentRefinementValue } from '../core/indexUtils';\nimport { addQueryID, addAbsolutePositions } from '../core/utils';\n\nvar getId = function getId() {\n  return 'query';\n};\n\nfunction getCurrentRefinement(props, searchState, context) {\n  var id = getId();\n  var currentRefinement = getCurrentRefinementValue(props, searchState, context, id, '');\n\n  if (currentRefinement) {\n    return currentRefinement;\n  }\n\n  return '';\n}\n\nfunction getHits(searchResults) {\n  if (searchResults.results) {\n    if (searchResults.results.hits && Array.isArray(searchResults.results.hits)) {\n      return addAbsolutePositions(addQueryID(searchResults.results.hits, searchResults.results.queryID), searchResults.results.hitsPerPage, searchResults.results.page);\n    } else {\n      return Object.keys(searchResults.results).reduce(function (hits, index) {\n        return [].concat(_toConsumableArray(hits), [{\n          index: index,\n          hits: addAbsolutePositions(addQueryID(searchResults.results[index].hits, searchResults.results[index].queryID), searchResults.results[index].hitsPerPage, searchResults.results[index].page)\n        }]);\n      }, []);\n    }\n  } else {\n    return [];\n  }\n}\n\nfunction _refine(props, searchState, nextRefinement, context) {\n  var id = getId();\n\n  var nextValue = _defineProperty({}, id, nextRefinement);\n\n  var resetPage = true;\n  return refineValue(searchState, nextValue, context, resetPage);\n}\n\nfunction _cleanUp(props, searchState, context) {\n  return cleanUpValue(searchState, context, getId());\n}\n/**\n * connectAutoComplete connector provides the logic to create connected\n * components that will render the results retrieved from\n * Algolia.\n *\n * To configure the number of hits retrieved, use [HitsPerPage widget](widgets/HitsPerPage.html),\n * [connectHitsPerPage connector](connectors/connectHitsPerPage.html) or pass the hitsPerPage\n * prop to a [Configure](guide/Search_parameters.html) widget.\n * @name connectAutoComplete\n * @kind connector\n * @propType {string} [defaultRefinement] - Provide a default value for the query\n * @providedPropType {array.<object>} hits - the records that matched the search state\n * @providedPropType {function} refine - a function to change the query\n * @providedPropType {string} currentRefinement - the query to search for\n */\n\n\nexport default createConnector({\n  displayName: 'AlgoliaAutoComplete',\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    return {\n      hits: getHits(searchResults),\n      currentRefinement: getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      })\n    };\n  },\n  refine: function refine(props, searchState, nextRefinement) {\n    return _refine(props, searchState, nextRefinement, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return _cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n\n  /**\n   * AutoComplete needs to be considered as a widget to trigger a search,\n   * even if no other widgets are used.\n   *\n   * To be considered as a widget you need either:\n   * - getSearchParameters\n   * - getMetadata\n   * - transitionState\n   *\n   * See: createConnector.tsx\n   */\n  getSearchParameters: function getSearchParameters(searchParameters, props, searchState) {\n    return searchParameters.setQuery(getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }));\n  }\n});"]},"metadata":{},"sourceType":"module"}