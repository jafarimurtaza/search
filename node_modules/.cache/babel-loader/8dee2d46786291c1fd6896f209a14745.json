{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport PropTypes from 'prop-types';\nimport createConnector from '../core/createConnector';\nimport { cleanUpValue, getIndexId, refineValue, getCurrentRefinementValue, getResults } from '../core/indexUtils';\n/**\n * connectRange connector provides the logic to create connected\n * components that will give the ability for a user to refine results using\n * a numeric range.\n * @name connectRange\n * @kind connector\n * @requirements The attribute passed to the `attribute` prop must be present in “attributes for faceting”\n * on the Algolia dashboard or configured as `attributesForFaceting` via a set settings call to the Algolia API.\n * The values inside the attribute must be JavaScript numbers (not strings).\n * @propType {string} attribute - Name of the attribute for faceting\n * @propType {{min?: number, max?: number}} [defaultRefinement] - Default searchState of the widget containing the start and the end of the range.\n * @propType {number} [min] - Minimum value. When this isn't set, the minimum value will be automatically computed by Algolia using the data in the index.\n * @propType {number} [max] - Maximum value. When this isn't set, the maximum value will be automatically computed by Algolia using the data in the index.\n * @propType {number} [precision=0] - Number of digits after decimal point to use.\n * @providedPropType {function} refine - a function to select a range.\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string} currentRefinement - the refinement currently applied\n * @providedPropType {number} min - the minimum value available.\n * @providedPropType {number} max - the maximum value available.\n * @providedPropType {number} precision - Number of digits after decimal point to use.\n */\n\nfunction getId(props) {\n  return props.attribute;\n}\n\nvar namespace = 'range';\n\nfunction getCurrentRange(boundaries, stats, precision) {\n  var pow = Math.pow(10, precision);\n  var min;\n\n  if (typeof boundaries.min === 'number' && isFinite(boundaries.min)) {\n    min = boundaries.min;\n  } else if (typeof stats.min === 'number' && isFinite(stats.min)) {\n    min = stats.min;\n  } else {\n    min = undefined;\n  }\n\n  var max;\n\n  if (typeof boundaries.max === 'number' && isFinite(boundaries.max)) {\n    max = boundaries.max;\n  } else if (typeof stats.max === 'number' && isFinite(stats.max)) {\n    max = stats.max;\n  } else {\n    max = undefined;\n  }\n\n  return {\n    min: min !== undefined ? Math.floor(min * pow) / pow : min,\n    max: max !== undefined ? Math.ceil(max * pow) / pow : max\n  };\n}\n\nfunction getCurrentRefinement(props, searchState, currentRange, context) {\n  var _getCurrentRefinement = getCurrentRefinementValue(props, searchState, context, \"\".concat(namespace, \".\").concat(getId(props)), {}),\n      min = _getCurrentRefinement.min,\n      max = _getCurrentRefinement.max;\n\n  var isFloatPrecision = Boolean(props.precision);\n  var nextMin = min;\n\n  if (typeof nextMin === 'string') {\n    nextMin = isFloatPrecision ? parseFloat(nextMin) : parseInt(nextMin, 10);\n  }\n\n  var nextMax = max;\n\n  if (typeof nextMax === 'string') {\n    nextMax = isFloatPrecision ? parseFloat(nextMax) : parseInt(nextMax, 10);\n  }\n\n  var refinement = {\n    min: nextMin,\n    max: nextMax\n  };\n  var hasMinBound = props.min !== undefined;\n  var hasMaxBound = props.max !== undefined;\n  var hasMinRefinment = refinement.min !== undefined;\n  var hasMaxRefinment = refinement.max !== undefined;\n\n  if (hasMinBound && hasMinRefinment && refinement.min < currentRange.min) {\n    throw Error(\"You can't provide min value lower than range.\");\n  }\n\n  if (hasMaxBound && hasMaxRefinment && refinement.max > currentRange.max) {\n    throw Error(\"You can't provide max value greater than range.\");\n  }\n\n  if (hasMinBound && !hasMinRefinment) {\n    refinement.min = currentRange.min;\n  }\n\n  if (hasMaxBound && !hasMaxRefinment) {\n    refinement.max = currentRange.max;\n  }\n\n  return refinement;\n}\n\nfunction getCurrentRefinementWithRange(refinement, range) {\n  return {\n    min: refinement.min !== undefined ? refinement.min : range.min,\n    max: refinement.max !== undefined ? refinement.max : range.max\n  };\n}\n\nfunction nextValueForRefinement(hasBound, isReset, range, value) {\n  var next;\n\n  if (!hasBound && range === value) {\n    next = undefined;\n  } else if (hasBound && isReset) {\n    next = range;\n  } else {\n    next = value;\n  }\n\n  return next;\n}\n\nfunction _refine(props, searchState, nextRefinement, currentRange, context) {\n  var nextMin = nextRefinement.min,\n      nextMax = nextRefinement.max;\n  var currentMinRange = currentRange.min,\n      currentMaxRange = currentRange.max;\n  var isMinReset = nextMin === undefined || nextMin === '';\n  var isMaxReset = nextMax === undefined || nextMax === '';\n  var nextMinAsNumber = !isMinReset ? parseFloat(nextMin) : undefined;\n  var nextMaxAsNumber = !isMaxReset ? parseFloat(nextMax) : undefined;\n  var isNextMinValid = isMinReset || isFinite(nextMinAsNumber);\n  var isNextMaxValid = isMaxReset || isFinite(nextMaxAsNumber);\n\n  if (!isNextMinValid || !isNextMaxValid) {\n    throw Error(\"You can't provide non finite values to the range connector.\");\n  }\n\n  if (nextMinAsNumber < currentMinRange) {\n    throw Error(\"You can't provide min value lower than range.\");\n  }\n\n  if (nextMaxAsNumber > currentMaxRange) {\n    throw Error(\"You can't provide max value greater than range.\");\n  }\n\n  var id = getId(props);\n  var resetPage = true;\n\n  var nextValue = _defineProperty({}, id, {\n    min: nextValueForRefinement(props.min !== undefined, isMinReset, currentMinRange, nextMinAsNumber),\n    max: nextValueForRefinement(props.max !== undefined, isMaxReset, currentMaxRange, nextMaxAsNumber)\n  });\n\n  return refineValue(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction _cleanUp(props, searchState, context) {\n  return cleanUpValue(searchState, context, \"\".concat(namespace, \".\").concat(getId(props)));\n}\n\nexport default createConnector({\n  displayName: 'AlgoliaRange',\n  propTypes: {\n    id: PropTypes.string,\n    attribute: PropTypes.string.isRequired,\n    defaultRefinement: PropTypes.shape({\n      min: PropTypes.number,\n      max: PropTypes.number\n    }),\n    min: PropTypes.number,\n    max: PropTypes.number,\n    precision: PropTypes.number,\n    header: PropTypes.node,\n    footer: PropTypes.node\n  },\n  defaultProps: {\n    precision: 0\n  },\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var attribute = props.attribute,\n        precision = props.precision,\n        minBound = props.min,\n        maxBound = props.max;\n    var results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    var hasFacet = results && results.getFacetByName(attribute);\n    var stats = hasFacet ? results.getFacetStats(attribute) || {} : {};\n    var facetValues = hasFacet ? results.getFacetValues(attribute) : [];\n    var count = facetValues.map(function (v) {\n      return {\n        value: v.name,\n        count: v.count\n      };\n    });\n\n    var _getCurrentRange = getCurrentRange({\n      min: minBound,\n      max: maxBound\n    }, stats, precision),\n        rangeMin = _getCurrentRange.min,\n        rangeMax = _getCurrentRange.max; // The searchState is not always in sync with the helper state. For example\n    // when we set boundaries on the first render the searchState don't have\n    // the correct refinement. If this behavior change in the upcoming version\n    // we could store the range inside the searchState instead of rely on `this`.\n\n\n    this._currentRange = {\n      min: rangeMin,\n      max: rangeMax\n    };\n    var currentRefinement = getCurrentRefinement(props, searchState, this._currentRange, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    return {\n      min: rangeMin,\n      max: rangeMax,\n      canRefine: count.length > 0,\n      currentRefinement: getCurrentRefinementWithRange(currentRefinement, this._currentRange),\n      count: count,\n      precision: precision\n    };\n  },\n  refine: function refine(props, searchState, nextRefinement) {\n    return _refine(props, searchState, nextRefinement, this._currentRange, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return _cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  getSearchParameters: function getSearchParameters(params, props, searchState) {\n    var attribute = props.attribute;\n\n    var _getCurrentRefinement2 = getCurrentRefinement(props, searchState, this._currentRange, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }),\n        min = _getCurrentRefinement2.min,\n        max = _getCurrentRefinement2.max;\n\n    params = params.addDisjunctiveFacet(attribute);\n\n    if (min !== undefined) {\n      params = params.addNumericRefinement(attribute, '>=', min);\n    }\n\n    if (max !== undefined) {\n      params = params.addNumericRefinement(attribute, '<=', max);\n    }\n\n    return params;\n  },\n  getMetadata: function getMetadata(props, searchState) {\n    var _this = this;\n\n    var _this$_currentRange = this._currentRange,\n        minRange = _this$_currentRange.min,\n        maxRange = _this$_currentRange.max;\n\n    var _getCurrentRefinement3 = getCurrentRefinement(props, searchState, this._currentRange, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }),\n        minValue = _getCurrentRefinement3.min,\n        maxValue = _getCurrentRefinement3.max;\n\n    var items = [];\n    var hasMin = minValue !== undefined;\n    var hasMax = maxValue !== undefined;\n    var shouldDisplayMinLabel = hasMin && minValue !== minRange;\n    var shouldDisplayMaxLabel = hasMax && maxValue !== maxRange;\n\n    if (shouldDisplayMinLabel || shouldDisplayMaxLabel) {\n      var fragments = [hasMin ? \"\".concat(minValue, \" <= \") : '', props.attribute, hasMax ? \" <= \".concat(maxValue) : ''];\n      items.push({\n        label: fragments.join(''),\n        attribute: props.attribute,\n        value: function value(nextState) {\n          return _refine(props, nextState, {}, _this._currentRange, {\n            ais: props.contextValue,\n            multiIndexContext: props.indexContextValue\n          });\n        },\n        currentRefinement: getCurrentRefinementWithRange({\n          min: minValue,\n          max: maxValue\n        }, {\n          min: minRange,\n          max: maxRange\n        })\n      });\n    }\n\n    return {\n      id: getId(props),\n      index: getIndexId({\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      }),\n      items: items\n    };\n  }\n});","map":{"version":3,"sources":["C:/Users/Murtaza Jafari/Desktop/product-search/product/searcbox/node_modules/react-instantsearch-core/dist/es/connectors/connectRange.js"],"names":["_defineProperty","PropTypes","createConnector","cleanUpValue","getIndexId","refineValue","getCurrentRefinementValue","getResults","getId","props","attribute","namespace","getCurrentRange","boundaries","stats","precision","pow","Math","min","isFinite","undefined","max","floor","ceil","getCurrentRefinement","searchState","currentRange","context","_getCurrentRefinement","concat","isFloatPrecision","Boolean","nextMin","parseFloat","parseInt","nextMax","refinement","hasMinBound","hasMaxBound","hasMinRefinment","hasMaxRefinment","Error","getCurrentRefinementWithRange","range","nextValueForRefinement","hasBound","isReset","value","next","_refine","nextRefinement","currentMinRange","currentMaxRange","isMinReset","isMaxReset","nextMinAsNumber","nextMaxAsNumber","isNextMinValid","isNextMaxValid","id","resetPage","nextValue","_cleanUp","displayName","propTypes","string","isRequired","defaultRefinement","shape","number","header","node","footer","defaultProps","getProvidedProps","searchResults","minBound","maxBound","results","ais","contextValue","multiIndexContext","indexContextValue","hasFacet","getFacetByName","getFacetStats","facetValues","getFacetValues","count","map","v","name","_getCurrentRange","rangeMin","rangeMax","_currentRange","currentRefinement","canRefine","length","refine","cleanUp","getSearchParameters","params","_getCurrentRefinement2","addDisjunctiveFacet","addNumericRefinement","getMetadata","_this","_this$_currentRange","minRange","maxRange","_getCurrentRefinement3","minValue","maxValue","items","hasMin","hasMax","shouldDisplayMinLabel","shouldDisplayMaxLabel","fragments","push","label","join","nextState","index"],"mappings":"AAAA,OAAOA,eAAP,MAA4B,2CAA5B;AACA,OAAOC,SAAP,MAAsB,YAAtB;AACA,OAAOC,eAAP,MAA4B,yBAA5B;AACA,SAASC,YAAT,EAAuBC,UAAvB,EAAmCC,WAAnC,EAAgDC,yBAAhD,EAA2EC,UAA3E,QAA6F,oBAA7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,KAAT,CAAeC,KAAf,EAAsB;AACpB,SAAOA,KAAK,CAACC,SAAb;AACD;;AAED,IAAIC,SAAS,GAAG,OAAhB;;AAEA,SAASC,eAAT,CAAyBC,UAAzB,EAAqCC,KAArC,EAA4CC,SAA5C,EAAuD;AACrD,MAAIC,GAAG,GAAGC,IAAI,CAACD,GAAL,CAAS,EAAT,EAAaD,SAAb,CAAV;AACA,MAAIG,GAAJ;;AAEA,MAAI,OAAOL,UAAU,CAACK,GAAlB,KAA0B,QAA1B,IAAsCC,QAAQ,CAACN,UAAU,CAACK,GAAZ,CAAlD,EAAoE;AAClEA,IAAAA,GAAG,GAAGL,UAAU,CAACK,GAAjB;AACD,GAFD,MAEO,IAAI,OAAOJ,KAAK,CAACI,GAAb,KAAqB,QAArB,IAAiCC,QAAQ,CAACL,KAAK,CAACI,GAAP,CAA7C,EAA0D;AAC/DA,IAAAA,GAAG,GAAGJ,KAAK,CAACI,GAAZ;AACD,GAFM,MAEA;AACLA,IAAAA,GAAG,GAAGE,SAAN;AACD;;AAED,MAAIC,GAAJ;;AAEA,MAAI,OAAOR,UAAU,CAACQ,GAAlB,KAA0B,QAA1B,IAAsCF,QAAQ,CAACN,UAAU,CAACQ,GAAZ,CAAlD,EAAoE;AAClEA,IAAAA,GAAG,GAAGR,UAAU,CAACQ,GAAjB;AACD,GAFD,MAEO,IAAI,OAAOP,KAAK,CAACO,GAAb,KAAqB,QAArB,IAAiCF,QAAQ,CAACL,KAAK,CAACO,GAAP,CAA7C,EAA0D;AAC/DA,IAAAA,GAAG,GAAGP,KAAK,CAACO,GAAZ;AACD,GAFM,MAEA;AACLA,IAAAA,GAAG,GAAGD,SAAN;AACD;;AAED,SAAO;AACLF,IAAAA,GAAG,EAAEA,GAAG,KAAKE,SAAR,GAAoBH,IAAI,CAACK,KAAL,CAAWJ,GAAG,GAAGF,GAAjB,IAAwBA,GAA5C,GAAkDE,GADlD;AAELG,IAAAA,GAAG,EAAEA,GAAG,KAAKD,SAAR,GAAoBH,IAAI,CAACM,IAAL,CAAUF,GAAG,GAAGL,GAAhB,IAAuBA,GAA3C,GAAiDK;AAFjD,GAAP;AAID;;AAED,SAASG,oBAAT,CAA8Bf,KAA9B,EAAqCgB,WAArC,EAAkDC,YAAlD,EAAgEC,OAAhE,EAAyE;AACvE,MAAIC,qBAAqB,GAAGtB,yBAAyB,CAACG,KAAD,EAAQgB,WAAR,EAAqBE,OAArB,EAA8B,GAAGE,MAAH,CAAUlB,SAAV,EAAqB,GAArB,EAA0BkB,MAA1B,CAAiCrB,KAAK,CAACC,KAAD,CAAtC,CAA9B,EAA8E,EAA9E,CAArD;AAAA,MACIS,GAAG,GAAGU,qBAAqB,CAACV,GADhC;AAAA,MAEIG,GAAG,GAAGO,qBAAqB,CAACP,GAFhC;;AAIA,MAAIS,gBAAgB,GAAGC,OAAO,CAACtB,KAAK,CAACM,SAAP,CAA9B;AACA,MAAIiB,OAAO,GAAGd,GAAd;;AAEA,MAAI,OAAOc,OAAP,KAAmB,QAAvB,EAAiC;AAC/BA,IAAAA,OAAO,GAAGF,gBAAgB,GAAGG,UAAU,CAACD,OAAD,CAAb,GAAyBE,QAAQ,CAACF,OAAD,EAAU,EAAV,CAA3D;AACD;;AAED,MAAIG,OAAO,GAAGd,GAAd;;AAEA,MAAI,OAAOc,OAAP,KAAmB,QAAvB,EAAiC;AAC/BA,IAAAA,OAAO,GAAGL,gBAAgB,GAAGG,UAAU,CAACE,OAAD,CAAb,GAAyBD,QAAQ,CAACC,OAAD,EAAU,EAAV,CAA3D;AACD;;AAED,MAAIC,UAAU,GAAG;AACflB,IAAAA,GAAG,EAAEc,OADU;AAEfX,IAAAA,GAAG,EAAEc;AAFU,GAAjB;AAIA,MAAIE,WAAW,GAAG5B,KAAK,CAACS,GAAN,KAAcE,SAAhC;AACA,MAAIkB,WAAW,GAAG7B,KAAK,CAACY,GAAN,KAAcD,SAAhC;AACA,MAAImB,eAAe,GAAGH,UAAU,CAAClB,GAAX,KAAmBE,SAAzC;AACA,MAAIoB,eAAe,GAAGJ,UAAU,CAACf,GAAX,KAAmBD,SAAzC;;AAEA,MAAIiB,WAAW,IAAIE,eAAf,IAAkCH,UAAU,CAAClB,GAAX,GAAiBQ,YAAY,CAACR,GAApE,EAAyE;AACvE,UAAMuB,KAAK,CAAC,+CAAD,CAAX;AACD;;AAED,MAAIH,WAAW,IAAIE,eAAf,IAAkCJ,UAAU,CAACf,GAAX,GAAiBK,YAAY,CAACL,GAApE,EAAyE;AACvE,UAAMoB,KAAK,CAAC,iDAAD,CAAX;AACD;;AAED,MAAIJ,WAAW,IAAI,CAACE,eAApB,EAAqC;AACnCH,IAAAA,UAAU,CAAClB,GAAX,GAAiBQ,YAAY,CAACR,GAA9B;AACD;;AAED,MAAIoB,WAAW,IAAI,CAACE,eAApB,EAAqC;AACnCJ,IAAAA,UAAU,CAACf,GAAX,GAAiBK,YAAY,CAACL,GAA9B;AACD;;AAED,SAAOe,UAAP;AACD;;AAED,SAASM,6BAAT,CAAuCN,UAAvC,EAAmDO,KAAnD,EAA0D;AACxD,SAAO;AACLzB,IAAAA,GAAG,EAAEkB,UAAU,CAAClB,GAAX,KAAmBE,SAAnB,GAA+BgB,UAAU,CAAClB,GAA1C,GAAgDyB,KAAK,CAACzB,GADtD;AAELG,IAAAA,GAAG,EAAEe,UAAU,CAACf,GAAX,KAAmBD,SAAnB,GAA+BgB,UAAU,CAACf,GAA1C,GAAgDsB,KAAK,CAACtB;AAFtD,GAAP;AAID;;AAED,SAASuB,sBAAT,CAAgCC,QAAhC,EAA0CC,OAA1C,EAAmDH,KAAnD,EAA0DI,KAA1D,EAAiE;AAC/D,MAAIC,IAAJ;;AAEA,MAAI,CAACH,QAAD,IAAaF,KAAK,KAAKI,KAA3B,EAAkC;AAChCC,IAAAA,IAAI,GAAG5B,SAAP;AACD,GAFD,MAEO,IAAIyB,QAAQ,IAAIC,OAAhB,EAAyB;AAC9BE,IAAAA,IAAI,GAAGL,KAAP;AACD,GAFM,MAEA;AACLK,IAAAA,IAAI,GAAGD,KAAP;AACD;;AAED,SAAOC,IAAP;AACD;;AAED,SAASC,OAAT,CAAiBxC,KAAjB,EAAwBgB,WAAxB,EAAqCyB,cAArC,EAAqDxB,YAArD,EAAmEC,OAAnE,EAA4E;AAC1E,MAAIK,OAAO,GAAGkB,cAAc,CAAChC,GAA7B;AAAA,MACIiB,OAAO,GAAGe,cAAc,CAAC7B,GAD7B;AAEA,MAAI8B,eAAe,GAAGzB,YAAY,CAACR,GAAnC;AAAA,MACIkC,eAAe,GAAG1B,YAAY,CAACL,GADnC;AAEA,MAAIgC,UAAU,GAAGrB,OAAO,KAAKZ,SAAZ,IAAyBY,OAAO,KAAK,EAAtD;AACA,MAAIsB,UAAU,GAAGnB,OAAO,KAAKf,SAAZ,IAAyBe,OAAO,KAAK,EAAtD;AACA,MAAIoB,eAAe,GAAG,CAACF,UAAD,GAAcpB,UAAU,CAACD,OAAD,CAAxB,GAAoCZ,SAA1D;AACA,MAAIoC,eAAe,GAAG,CAACF,UAAD,GAAcrB,UAAU,CAACE,OAAD,CAAxB,GAAoCf,SAA1D;AACA,MAAIqC,cAAc,GAAGJ,UAAU,IAAIlC,QAAQ,CAACoC,eAAD,CAA3C;AACA,MAAIG,cAAc,GAAGJ,UAAU,IAAInC,QAAQ,CAACqC,eAAD,CAA3C;;AAEA,MAAI,CAACC,cAAD,IAAmB,CAACC,cAAxB,EAAwC;AACtC,UAAMjB,KAAK,CAAC,6DAAD,CAAX;AACD;;AAED,MAAIc,eAAe,GAAGJ,eAAtB,EAAuC;AACrC,UAAMV,KAAK,CAAC,+CAAD,CAAX;AACD;;AAED,MAAIe,eAAe,GAAGJ,eAAtB,EAAuC;AACrC,UAAMX,KAAK,CAAC,iDAAD,CAAX;AACD;;AAED,MAAIkB,EAAE,GAAGnD,KAAK,CAACC,KAAD,CAAd;AACA,MAAImD,SAAS,GAAG,IAAhB;;AAEA,MAAIC,SAAS,GAAG7D,eAAe,CAAC,EAAD,EAAK2D,EAAL,EAAS;AACtCzC,IAAAA,GAAG,EAAE0B,sBAAsB,CAACnC,KAAK,CAACS,GAAN,KAAcE,SAAf,EAA0BiC,UAA1B,EAAsCF,eAAtC,EAAuDI,eAAvD,CADW;AAEtClC,IAAAA,GAAG,EAAEuB,sBAAsB,CAACnC,KAAK,CAACY,GAAN,KAAcD,SAAf,EAA0BkC,UAA1B,EAAsCF,eAAtC,EAAuDI,eAAvD;AAFW,GAAT,CAA/B;;AAKA,SAAOnD,WAAW,CAACoB,WAAD,EAAcoC,SAAd,EAAyBlC,OAAzB,EAAkCiC,SAAlC,EAA6CjD,SAA7C,CAAlB;AACD;;AAED,SAASmD,QAAT,CAAkBrD,KAAlB,EAAyBgB,WAAzB,EAAsCE,OAAtC,EAA+C;AAC7C,SAAOxB,YAAY,CAACsB,WAAD,EAAcE,OAAd,EAAuB,GAAGE,MAAH,CAAUlB,SAAV,EAAqB,GAArB,EAA0BkB,MAA1B,CAAiCrB,KAAK,CAACC,KAAD,CAAtC,CAAvB,CAAnB;AACD;;AAED,eAAeP,eAAe,CAAC;AAC7B6D,EAAAA,WAAW,EAAE,cADgB;AAE7BC,EAAAA,SAAS,EAAE;AACTL,IAAAA,EAAE,EAAE1D,SAAS,CAACgE,MADL;AAETvD,IAAAA,SAAS,EAAET,SAAS,CAACgE,MAAV,CAAiBC,UAFnB;AAGTC,IAAAA,iBAAiB,EAAElE,SAAS,CAACmE,KAAV,CAAgB;AACjClD,MAAAA,GAAG,EAAEjB,SAAS,CAACoE,MADkB;AAEjChD,MAAAA,GAAG,EAAEpB,SAAS,CAACoE;AAFkB,KAAhB,CAHV;AAOTnD,IAAAA,GAAG,EAAEjB,SAAS,CAACoE,MAPN;AAQThD,IAAAA,GAAG,EAAEpB,SAAS,CAACoE,MARN;AASTtD,IAAAA,SAAS,EAAEd,SAAS,CAACoE,MATZ;AAUTC,IAAAA,MAAM,EAAErE,SAAS,CAACsE,IAVT;AAWTC,IAAAA,MAAM,EAAEvE,SAAS,CAACsE;AAXT,GAFkB;AAe7BE,EAAAA,YAAY,EAAE;AACZ1D,IAAAA,SAAS,EAAE;AADC,GAfe;AAkB7B2D,EAAAA,gBAAgB,EAAE,SAASA,gBAAT,CAA0BjE,KAA1B,EAAiCgB,WAAjC,EAA8CkD,aAA9C,EAA6D;AAC7E,QAAIjE,SAAS,GAAGD,KAAK,CAACC,SAAtB;AAAA,QACIK,SAAS,GAAGN,KAAK,CAACM,SADtB;AAAA,QAEI6D,QAAQ,GAAGnE,KAAK,CAACS,GAFrB;AAAA,QAGI2D,QAAQ,GAAGpE,KAAK,CAACY,GAHrB;AAIA,QAAIyD,OAAO,GAAGvE,UAAU,CAACoE,aAAD,EAAgB;AACtCI,MAAAA,GAAG,EAAEtE,KAAK,CAACuE,YAD2B;AAEtCC,MAAAA,iBAAiB,EAAExE,KAAK,CAACyE;AAFa,KAAhB,CAAxB;AAIA,QAAIC,QAAQ,GAAGL,OAAO,IAAIA,OAAO,CAACM,cAAR,CAAuB1E,SAAvB,CAA1B;AACA,QAAII,KAAK,GAAGqE,QAAQ,GAAGL,OAAO,CAACO,aAAR,CAAsB3E,SAAtB,KAAoC,EAAvC,GAA4C,EAAhE;AACA,QAAI4E,WAAW,GAAGH,QAAQ,GAAGL,OAAO,CAACS,cAAR,CAAuB7E,SAAvB,CAAH,GAAuC,EAAjE;AACA,QAAI8E,KAAK,GAAGF,WAAW,CAACG,GAAZ,CAAgB,UAAUC,CAAV,EAAa;AACvC,aAAO;AACL3C,QAAAA,KAAK,EAAE2C,CAAC,CAACC,IADJ;AAELH,QAAAA,KAAK,EAAEE,CAAC,CAACF;AAFJ,OAAP;AAID,KALW,CAAZ;;AAOA,QAAII,gBAAgB,GAAGhF,eAAe,CAAC;AACrCM,MAAAA,GAAG,EAAE0D,QADgC;AAErCvD,MAAAA,GAAG,EAAEwD;AAFgC,KAAD,EAGnC/D,KAHmC,EAG5BC,SAH4B,CAAtC;AAAA,QAII8E,QAAQ,GAAGD,gBAAgB,CAAC1E,GAJhC;AAAA,QAKI4E,QAAQ,GAAGF,gBAAgB,CAACvE,GALhC,CAnB6E,CAwBxC;AACrC;AACA;AACA;;;AAGA,SAAK0E,aAAL,GAAqB;AACnB7E,MAAAA,GAAG,EAAE2E,QADc;AAEnBxE,MAAAA,GAAG,EAAEyE;AAFc,KAArB;AAIA,QAAIE,iBAAiB,GAAGxE,oBAAoB,CAACf,KAAD,EAAQgB,WAAR,EAAqB,KAAKsE,aAA1B,EAAyC;AACnFhB,MAAAA,GAAG,EAAEtE,KAAK,CAACuE,YADwE;AAEnFC,MAAAA,iBAAiB,EAAExE,KAAK,CAACyE;AAF0D,KAAzC,CAA5C;AAIA,WAAO;AACLhE,MAAAA,GAAG,EAAE2E,QADA;AAELxE,MAAAA,GAAG,EAAEyE,QAFA;AAGLG,MAAAA,SAAS,EAAET,KAAK,CAACU,MAAN,GAAe,CAHrB;AAILF,MAAAA,iBAAiB,EAAEtD,6BAA6B,CAACsD,iBAAD,EAAoB,KAAKD,aAAzB,CAJ3C;AAKLP,MAAAA,KAAK,EAAEA,KALF;AAMLzE,MAAAA,SAAS,EAAEA;AANN,KAAP;AAQD,GAhE4B;AAiE7BoF,EAAAA,MAAM,EAAE,SAASA,MAAT,CAAgB1F,KAAhB,EAAuBgB,WAAvB,EAAoCyB,cAApC,EAAoD;AAC1D,WAAOD,OAAO,CAACxC,KAAD,EAAQgB,WAAR,EAAqByB,cAArB,EAAqC,KAAK6C,aAA1C,EAAyD;AACrEhB,MAAAA,GAAG,EAAEtE,KAAK,CAACuE,YAD0D;AAErEC,MAAAA,iBAAiB,EAAExE,KAAK,CAACyE;AAF4C,KAAzD,CAAd;AAID,GAtE4B;AAuE7BkB,EAAAA,OAAO,EAAE,SAASA,OAAT,CAAiB3F,KAAjB,EAAwBgB,WAAxB,EAAqC;AAC5C,WAAOqC,QAAQ,CAACrD,KAAD,EAAQgB,WAAR,EAAqB;AAClCsD,MAAAA,GAAG,EAAEtE,KAAK,CAACuE,YADuB;AAElCC,MAAAA,iBAAiB,EAAExE,KAAK,CAACyE;AAFS,KAArB,CAAf;AAID,GA5E4B;AA6E7BmB,EAAAA,mBAAmB,EAAE,SAASA,mBAAT,CAA6BC,MAA7B,EAAqC7F,KAArC,EAA4CgB,WAA5C,EAAyD;AAC5E,QAAIf,SAAS,GAAGD,KAAK,CAACC,SAAtB;;AAEA,QAAI6F,sBAAsB,GAAG/E,oBAAoB,CAACf,KAAD,EAAQgB,WAAR,EAAqB,KAAKsE,aAA1B,EAAyC;AACxFhB,MAAAA,GAAG,EAAEtE,KAAK,CAACuE,YAD6E;AAExFC,MAAAA,iBAAiB,EAAExE,KAAK,CAACyE;AAF+D,KAAzC,CAAjD;AAAA,QAIIhE,GAAG,GAAGqF,sBAAsB,CAACrF,GAJjC;AAAA,QAKIG,GAAG,GAAGkF,sBAAsB,CAAClF,GALjC;;AAOAiF,IAAAA,MAAM,GAAGA,MAAM,CAACE,mBAAP,CAA2B9F,SAA3B,CAAT;;AAEA,QAAIQ,GAAG,KAAKE,SAAZ,EAAuB;AACrBkF,MAAAA,MAAM,GAAGA,MAAM,CAACG,oBAAP,CAA4B/F,SAA5B,EAAuC,IAAvC,EAA6CQ,GAA7C,CAAT;AACD;;AAED,QAAIG,GAAG,KAAKD,SAAZ,EAAuB;AACrBkF,MAAAA,MAAM,GAAGA,MAAM,CAACG,oBAAP,CAA4B/F,SAA5B,EAAuC,IAAvC,EAA6CW,GAA7C,CAAT;AACD;;AAED,WAAOiF,MAAP;AACD,GAlG4B;AAmG7BI,EAAAA,WAAW,EAAE,SAASA,WAAT,CAAqBjG,KAArB,EAA4BgB,WAA5B,EAAyC;AACpD,QAAIkF,KAAK,GAAG,IAAZ;;AAEA,QAAIC,mBAAmB,GAAG,KAAKb,aAA/B;AAAA,QACIc,QAAQ,GAAGD,mBAAmB,CAAC1F,GADnC;AAAA,QAEI4F,QAAQ,GAAGF,mBAAmB,CAACvF,GAFnC;;AAIA,QAAI0F,sBAAsB,GAAGvF,oBAAoB,CAACf,KAAD,EAAQgB,WAAR,EAAqB,KAAKsE,aAA1B,EAAyC;AACxFhB,MAAAA,GAAG,EAAEtE,KAAK,CAACuE,YAD6E;AAExFC,MAAAA,iBAAiB,EAAExE,KAAK,CAACyE;AAF+D,KAAzC,CAAjD;AAAA,QAII8B,QAAQ,GAAGD,sBAAsB,CAAC7F,GAJtC;AAAA,QAKI+F,QAAQ,GAAGF,sBAAsB,CAAC1F,GALtC;;AAOA,QAAI6F,KAAK,GAAG,EAAZ;AACA,QAAIC,MAAM,GAAGH,QAAQ,KAAK5F,SAA1B;AACA,QAAIgG,MAAM,GAAGH,QAAQ,KAAK7F,SAA1B;AACA,QAAIiG,qBAAqB,GAAGF,MAAM,IAAIH,QAAQ,KAAKH,QAAnD;AACA,QAAIS,qBAAqB,GAAGF,MAAM,IAAIH,QAAQ,KAAKH,QAAnD;;AAEA,QAAIO,qBAAqB,IAAIC,qBAA7B,EAAoD;AAClD,UAAIC,SAAS,GAAG,CAACJ,MAAM,GAAG,GAAGtF,MAAH,CAAUmF,QAAV,EAAoB,MAApB,CAAH,GAAiC,EAAxC,EAA4CvG,KAAK,CAACC,SAAlD,EAA6D0G,MAAM,GAAG,OAAOvF,MAAP,CAAcoF,QAAd,CAAH,GAA6B,EAAhG,CAAhB;AACAC,MAAAA,KAAK,CAACM,IAAN,CAAW;AACTC,QAAAA,KAAK,EAAEF,SAAS,CAACG,IAAV,CAAe,EAAf,CADE;AAEThH,QAAAA,SAAS,EAAED,KAAK,CAACC,SAFR;AAGTqC,QAAAA,KAAK,EAAE,SAASA,KAAT,CAAe4E,SAAf,EAA0B;AAC/B,iBAAO1E,OAAO,CAACxC,KAAD,EAAQkH,SAAR,EAAmB,EAAnB,EAAuBhB,KAAK,CAACZ,aAA7B,EAA4C;AACxDhB,YAAAA,GAAG,EAAEtE,KAAK,CAACuE,YAD6C;AAExDC,YAAAA,iBAAiB,EAAExE,KAAK,CAACyE;AAF+B,WAA5C,CAAd;AAID,SARQ;AASTc,QAAAA,iBAAiB,EAAEtD,6BAA6B,CAAC;AAC/CxB,UAAAA,GAAG,EAAE8F,QAD0C;AAE/C3F,UAAAA,GAAG,EAAE4F;AAF0C,SAAD,EAG7C;AACD/F,UAAAA,GAAG,EAAE2F,QADJ;AAEDxF,UAAAA,GAAG,EAAEyF;AAFJ,SAH6C;AATvC,OAAX;AAiBD;;AAED,WAAO;AACLnD,MAAAA,EAAE,EAAEnD,KAAK,CAACC,KAAD,CADJ;AAELmH,MAAAA,KAAK,EAAExH,UAAU,CAAC;AAChB2E,QAAAA,GAAG,EAAEtE,KAAK,CAACuE,YADK;AAEhBC,QAAAA,iBAAiB,EAAExE,KAAK,CAACyE;AAFT,OAAD,CAFZ;AAMLgC,MAAAA,KAAK,EAAEA;AANF,KAAP;AAQD;AApJ4B,CAAD,CAA9B","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport PropTypes from 'prop-types';\nimport createConnector from '../core/createConnector';\nimport { cleanUpValue, getIndexId, refineValue, getCurrentRefinementValue, getResults } from '../core/indexUtils';\n/**\n * connectRange connector provides the logic to create connected\n * components that will give the ability for a user to refine results using\n * a numeric range.\n * @name connectRange\n * @kind connector\n * @requirements The attribute passed to the `attribute` prop must be present in “attributes for faceting”\n * on the Algolia dashboard or configured as `attributesForFaceting` via a set settings call to the Algolia API.\n * The values inside the attribute must be JavaScript numbers (not strings).\n * @propType {string} attribute - Name of the attribute for faceting\n * @propType {{min?: number, max?: number}} [defaultRefinement] - Default searchState of the widget containing the start and the end of the range.\n * @propType {number} [min] - Minimum value. When this isn't set, the minimum value will be automatically computed by Algolia using the data in the index.\n * @propType {number} [max] - Maximum value. When this isn't set, the maximum value will be automatically computed by Algolia using the data in the index.\n * @propType {number} [precision=0] - Number of digits after decimal point to use.\n * @providedPropType {function} refine - a function to select a range.\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string} currentRefinement - the refinement currently applied\n * @providedPropType {number} min - the minimum value available.\n * @providedPropType {number} max - the maximum value available.\n * @providedPropType {number} precision - Number of digits after decimal point to use.\n */\n\nfunction getId(props) {\n  return props.attribute;\n}\n\nvar namespace = 'range';\n\nfunction getCurrentRange(boundaries, stats, precision) {\n  var pow = Math.pow(10, precision);\n  var min;\n\n  if (typeof boundaries.min === 'number' && isFinite(boundaries.min)) {\n    min = boundaries.min;\n  } else if (typeof stats.min === 'number' && isFinite(stats.min)) {\n    min = stats.min;\n  } else {\n    min = undefined;\n  }\n\n  var max;\n\n  if (typeof boundaries.max === 'number' && isFinite(boundaries.max)) {\n    max = boundaries.max;\n  } else if (typeof stats.max === 'number' && isFinite(stats.max)) {\n    max = stats.max;\n  } else {\n    max = undefined;\n  }\n\n  return {\n    min: min !== undefined ? Math.floor(min * pow) / pow : min,\n    max: max !== undefined ? Math.ceil(max * pow) / pow : max\n  };\n}\n\nfunction getCurrentRefinement(props, searchState, currentRange, context) {\n  var _getCurrentRefinement = getCurrentRefinementValue(props, searchState, context, \"\".concat(namespace, \".\").concat(getId(props)), {}),\n      min = _getCurrentRefinement.min,\n      max = _getCurrentRefinement.max;\n\n  var isFloatPrecision = Boolean(props.precision);\n  var nextMin = min;\n\n  if (typeof nextMin === 'string') {\n    nextMin = isFloatPrecision ? parseFloat(nextMin) : parseInt(nextMin, 10);\n  }\n\n  var nextMax = max;\n\n  if (typeof nextMax === 'string') {\n    nextMax = isFloatPrecision ? parseFloat(nextMax) : parseInt(nextMax, 10);\n  }\n\n  var refinement = {\n    min: nextMin,\n    max: nextMax\n  };\n  var hasMinBound = props.min !== undefined;\n  var hasMaxBound = props.max !== undefined;\n  var hasMinRefinment = refinement.min !== undefined;\n  var hasMaxRefinment = refinement.max !== undefined;\n\n  if (hasMinBound && hasMinRefinment && refinement.min < currentRange.min) {\n    throw Error(\"You can't provide min value lower than range.\");\n  }\n\n  if (hasMaxBound && hasMaxRefinment && refinement.max > currentRange.max) {\n    throw Error(\"You can't provide max value greater than range.\");\n  }\n\n  if (hasMinBound && !hasMinRefinment) {\n    refinement.min = currentRange.min;\n  }\n\n  if (hasMaxBound && !hasMaxRefinment) {\n    refinement.max = currentRange.max;\n  }\n\n  return refinement;\n}\n\nfunction getCurrentRefinementWithRange(refinement, range) {\n  return {\n    min: refinement.min !== undefined ? refinement.min : range.min,\n    max: refinement.max !== undefined ? refinement.max : range.max\n  };\n}\n\nfunction nextValueForRefinement(hasBound, isReset, range, value) {\n  var next;\n\n  if (!hasBound && range === value) {\n    next = undefined;\n  } else if (hasBound && isReset) {\n    next = range;\n  } else {\n    next = value;\n  }\n\n  return next;\n}\n\nfunction _refine(props, searchState, nextRefinement, currentRange, context) {\n  var nextMin = nextRefinement.min,\n      nextMax = nextRefinement.max;\n  var currentMinRange = currentRange.min,\n      currentMaxRange = currentRange.max;\n  var isMinReset = nextMin === undefined || nextMin === '';\n  var isMaxReset = nextMax === undefined || nextMax === '';\n  var nextMinAsNumber = !isMinReset ? parseFloat(nextMin) : undefined;\n  var nextMaxAsNumber = !isMaxReset ? parseFloat(nextMax) : undefined;\n  var isNextMinValid = isMinReset || isFinite(nextMinAsNumber);\n  var isNextMaxValid = isMaxReset || isFinite(nextMaxAsNumber);\n\n  if (!isNextMinValid || !isNextMaxValid) {\n    throw Error(\"You can't provide non finite values to the range connector.\");\n  }\n\n  if (nextMinAsNumber < currentMinRange) {\n    throw Error(\"You can't provide min value lower than range.\");\n  }\n\n  if (nextMaxAsNumber > currentMaxRange) {\n    throw Error(\"You can't provide max value greater than range.\");\n  }\n\n  var id = getId(props);\n  var resetPage = true;\n\n  var nextValue = _defineProperty({}, id, {\n    min: nextValueForRefinement(props.min !== undefined, isMinReset, currentMinRange, nextMinAsNumber),\n    max: nextValueForRefinement(props.max !== undefined, isMaxReset, currentMaxRange, nextMaxAsNumber)\n  });\n\n  return refineValue(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction _cleanUp(props, searchState, context) {\n  return cleanUpValue(searchState, context, \"\".concat(namespace, \".\").concat(getId(props)));\n}\n\nexport default createConnector({\n  displayName: 'AlgoliaRange',\n  propTypes: {\n    id: PropTypes.string,\n    attribute: PropTypes.string.isRequired,\n    defaultRefinement: PropTypes.shape({\n      min: PropTypes.number,\n      max: PropTypes.number\n    }),\n    min: PropTypes.number,\n    max: PropTypes.number,\n    precision: PropTypes.number,\n    header: PropTypes.node,\n    footer: PropTypes.node\n  },\n  defaultProps: {\n    precision: 0\n  },\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var attribute = props.attribute,\n        precision = props.precision,\n        minBound = props.min,\n        maxBound = props.max;\n    var results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    var hasFacet = results && results.getFacetByName(attribute);\n    var stats = hasFacet ? results.getFacetStats(attribute) || {} : {};\n    var facetValues = hasFacet ? results.getFacetValues(attribute) : [];\n    var count = facetValues.map(function (v) {\n      return {\n        value: v.name,\n        count: v.count\n      };\n    });\n\n    var _getCurrentRange = getCurrentRange({\n      min: minBound,\n      max: maxBound\n    }, stats, precision),\n        rangeMin = _getCurrentRange.min,\n        rangeMax = _getCurrentRange.max; // The searchState is not always in sync with the helper state. For example\n    // when we set boundaries on the first render the searchState don't have\n    // the correct refinement. If this behavior change in the upcoming version\n    // we could store the range inside the searchState instead of rely on `this`.\n\n\n    this._currentRange = {\n      min: rangeMin,\n      max: rangeMax\n    };\n    var currentRefinement = getCurrentRefinement(props, searchState, this._currentRange, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    return {\n      min: rangeMin,\n      max: rangeMax,\n      canRefine: count.length > 0,\n      currentRefinement: getCurrentRefinementWithRange(currentRefinement, this._currentRange),\n      count: count,\n      precision: precision\n    };\n  },\n  refine: function refine(props, searchState, nextRefinement) {\n    return _refine(props, searchState, nextRefinement, this._currentRange, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return _cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  getSearchParameters: function getSearchParameters(params, props, searchState) {\n    var attribute = props.attribute;\n\n    var _getCurrentRefinement2 = getCurrentRefinement(props, searchState, this._currentRange, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }),\n        min = _getCurrentRefinement2.min,\n        max = _getCurrentRefinement2.max;\n\n    params = params.addDisjunctiveFacet(attribute);\n\n    if (min !== undefined) {\n      params = params.addNumericRefinement(attribute, '>=', min);\n    }\n\n    if (max !== undefined) {\n      params = params.addNumericRefinement(attribute, '<=', max);\n    }\n\n    return params;\n  },\n  getMetadata: function getMetadata(props, searchState) {\n    var _this = this;\n\n    var _this$_currentRange = this._currentRange,\n        minRange = _this$_currentRange.min,\n        maxRange = _this$_currentRange.max;\n\n    var _getCurrentRefinement3 = getCurrentRefinement(props, searchState, this._currentRange, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }),\n        minValue = _getCurrentRefinement3.min,\n        maxValue = _getCurrentRefinement3.max;\n\n    var items = [];\n    var hasMin = minValue !== undefined;\n    var hasMax = maxValue !== undefined;\n    var shouldDisplayMinLabel = hasMin && minValue !== minRange;\n    var shouldDisplayMaxLabel = hasMax && maxValue !== maxRange;\n\n    if (shouldDisplayMinLabel || shouldDisplayMaxLabel) {\n      var fragments = [hasMin ? \"\".concat(minValue, \" <= \") : '', props.attribute, hasMax ? \" <= \".concat(maxValue) : ''];\n      items.push({\n        label: fragments.join(''),\n        attribute: props.attribute,\n        value: function value(nextState) {\n          return _refine(props, nextState, {}, _this._currentRange, {\n            ais: props.contextValue,\n            multiIndexContext: props.indexContextValue\n          });\n        },\n        currentRefinement: getCurrentRefinementWithRange({\n          min: minValue,\n          max: maxValue\n        }, {\n          min: minRange,\n          max: maxRange\n        })\n      });\n    }\n\n    return {\n      id: getId(props),\n      index: getIndexId({\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      }),\n      items: items\n    };\n  }\n});"]},"metadata":{},"sourceType":"module"}