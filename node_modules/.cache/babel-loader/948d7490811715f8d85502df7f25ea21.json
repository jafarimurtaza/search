{"ast":null,"code":"'use strict';\n\nmodule.exports = generateTrees;\n\nvar orderBy = require('../functions/orderBy');\n\nvar find = require('../functions/find');\n\nvar prepareHierarchicalFacetSortBy = require('../functions/formatSort');\n\nfunction generateTrees(state) {\n  return function generate(hierarchicalFacetResult, hierarchicalFacetIndex) {\n    var hierarchicalFacet = state.hierarchicalFacets[hierarchicalFacetIndex];\n    var hierarchicalFacetRefinement = state.hierarchicalFacetsRefinements[hierarchicalFacet.name] && state.hierarchicalFacetsRefinements[hierarchicalFacet.name][0] || '';\n\n    var hierarchicalSeparator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n\n    var hierarchicalRootPath = state._getHierarchicalRootPath(hierarchicalFacet);\n\n    var hierarchicalShowParentLevel = state._getHierarchicalShowParentLevel(hierarchicalFacet);\n\n    var sortBy = prepareHierarchicalFacetSortBy(state._getHierarchicalFacetSortBy(hierarchicalFacet));\n    var rootExhaustive = hierarchicalFacetResult.every(function (facetResult) {\n      return facetResult.exhaustive;\n    });\n    var generateTreeFn = generateHierarchicalTree(sortBy, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel, hierarchicalFacetRefinement);\n    var results = hierarchicalFacetResult;\n\n    if (hierarchicalRootPath) {\n      results = hierarchicalFacetResult.slice(hierarchicalRootPath.split(hierarchicalSeparator).length);\n    }\n\n    return results.reduce(generateTreeFn, {\n      name: state.hierarchicalFacets[hierarchicalFacetIndex].name,\n      count: null,\n      // root level, no count\n      isRefined: true,\n      // root level, always refined\n      path: null,\n      // root level, no path\n      exhaustive: rootExhaustive,\n      data: null\n    });\n  };\n}\n\nfunction generateHierarchicalTree(sortBy, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel, currentRefinement) {\n  return function generateTree(hierarchicalTree, hierarchicalFacetResult, currentHierarchicalLevel) {\n    var parent = hierarchicalTree;\n\n    if (currentHierarchicalLevel > 0) {\n      var level = 0;\n      parent = hierarchicalTree;\n\n      while (level < currentHierarchicalLevel) {\n        /**\n         * @type {object[]]} hierarchical data\n         */\n        var data = parent && Array.isArray(parent.data) ? parent.data : [];\n        parent = find(data, function (subtree) {\n          return subtree.isRefined;\n        });\n        level++;\n      }\n    } // we found a refined parent, let's add current level data under it\n\n\n    if (parent) {\n      // filter values in case an object has multiple categories:\n      //   {\n      //     categories: {\n      //       level0: ['beers', 'bières'],\n      //       level1: ['beers > IPA', 'bières > Belges']\n      //     }\n      //   }\n      //\n      // If parent refinement is `beers`, then we do not want to have `bières > Belges`\n      // showing up\n      var picked = Object.keys(hierarchicalFacetResult.data).map(function (facetValue) {\n        return [facetValue, hierarchicalFacetResult.data[facetValue]];\n      }).filter(function (tuple) {\n        var facetValue = tuple[0];\n        return onlyMatchingTree(facetValue, parent.path || hierarchicalRootPath, currentRefinement, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel);\n      });\n      parent.data = orderBy(picked.map(function (tuple) {\n        var facetValue = tuple[0];\n        var facetCount = tuple[1];\n        return format(facetCount, facetValue, hierarchicalSeparator, currentRefinement, hierarchicalFacetResult.exhaustive);\n      }), sortBy[0], sortBy[1]);\n    }\n\n    return hierarchicalTree;\n  };\n}\n\nfunction onlyMatchingTree(facetValue, parentPath, currentRefinement, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel) {\n  // we want the facetValue is a child of hierarchicalRootPath\n  if (hierarchicalRootPath && (facetValue.indexOf(hierarchicalRootPath) !== 0 || hierarchicalRootPath === facetValue)) {\n    return false;\n  } // we always want root levels (only when there is no prefix path)\n\n\n  return !hierarchicalRootPath && facetValue.indexOf(hierarchicalSeparator) === -1 || // if there is a rootPath, being root level mean 1 level under rootPath\n  hierarchicalRootPath && facetValue.split(hierarchicalSeparator).length - hierarchicalRootPath.split(hierarchicalSeparator).length === 1 || // if current refinement is a root level and current facetValue is a root level,\n  // keep the facetValue\n  facetValue.indexOf(hierarchicalSeparator) === -1 && currentRefinement.indexOf(hierarchicalSeparator) === -1 || // currentRefinement is a child of the facet value\n  currentRefinement.indexOf(facetValue) === 0 || // facetValue is a child of the current parent, add it\n  facetValue.indexOf(parentPath + hierarchicalSeparator) === 0 && (hierarchicalShowParentLevel || facetValue.indexOf(currentRefinement) === 0);\n}\n\nfunction format(facetCount, facetValue, hierarchicalSeparator, currentRefinement, exhaustive) {\n  var parts = facetValue.split(hierarchicalSeparator);\n  return {\n    name: parts[parts.length - 1].trim(),\n    path: facetValue,\n    count: facetCount,\n    isRefined: currentRefinement === facetValue || currentRefinement.indexOf(facetValue + hierarchicalSeparator) === 0,\n    exhaustive: exhaustive,\n    data: null\n  };\n}","map":{"version":3,"sources":["C:/Users/Murtaza Jafari/Desktop/product-search/product/searcbox/node_modules/algoliasearch-helper/src/SearchResults/generate-hierarchical-tree.js"],"names":["module","exports","generateTrees","orderBy","require","find","prepareHierarchicalFacetSortBy","state","generate","hierarchicalFacetResult","hierarchicalFacetIndex","hierarchicalFacet","hierarchicalFacets","hierarchicalFacetRefinement","hierarchicalFacetsRefinements","name","hierarchicalSeparator","_getHierarchicalFacetSeparator","hierarchicalRootPath","_getHierarchicalRootPath","hierarchicalShowParentLevel","_getHierarchicalShowParentLevel","sortBy","_getHierarchicalFacetSortBy","rootExhaustive","every","facetResult","exhaustive","generateTreeFn","generateHierarchicalTree","results","slice","split","length","reduce","count","isRefined","path","data","currentRefinement","generateTree","hierarchicalTree","currentHierarchicalLevel","parent","level","Array","isArray","subtree","picked","Object","keys","map","facetValue","filter","tuple","onlyMatchingTree","facetCount","format","parentPath","indexOf","parts","trim"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = generateTrees;\n\nvar orderBy = require('../functions/orderBy');\nvar find = require('../functions/find');\nvar prepareHierarchicalFacetSortBy = require('../functions/formatSort');\n\nfunction generateTrees(state) {\n  return function generate(hierarchicalFacetResult, hierarchicalFacetIndex) {\n    var hierarchicalFacet = state.hierarchicalFacets[hierarchicalFacetIndex];\n    var hierarchicalFacetRefinement =\n      (state.hierarchicalFacetsRefinements[hierarchicalFacet.name] &&\n        state.hierarchicalFacetsRefinements[hierarchicalFacet.name][0]) ||\n      '';\n    var hierarchicalSeparator = state._getHierarchicalFacetSeparator(\n      hierarchicalFacet\n    );\n    var hierarchicalRootPath = state._getHierarchicalRootPath(\n      hierarchicalFacet\n    );\n    var hierarchicalShowParentLevel = state._getHierarchicalShowParentLevel(\n      hierarchicalFacet\n    );\n    var sortBy = prepareHierarchicalFacetSortBy(\n      state._getHierarchicalFacetSortBy(hierarchicalFacet)\n    );\n\n    var rootExhaustive = hierarchicalFacetResult.every(function(facetResult) {\n      return facetResult.exhaustive;\n    });\n\n    var generateTreeFn = generateHierarchicalTree(\n      sortBy,\n      hierarchicalSeparator,\n      hierarchicalRootPath,\n      hierarchicalShowParentLevel,\n      hierarchicalFacetRefinement\n    );\n\n    var results = hierarchicalFacetResult;\n\n    if (hierarchicalRootPath) {\n      results = hierarchicalFacetResult.slice(\n        hierarchicalRootPath.split(hierarchicalSeparator).length\n      );\n    }\n\n    return results.reduce(generateTreeFn, {\n      name: state.hierarchicalFacets[hierarchicalFacetIndex].name,\n      count: null, // root level, no count\n      isRefined: true, // root level, always refined\n      path: null, // root level, no path\n      exhaustive: rootExhaustive,\n      data: null\n    });\n  };\n}\n\nfunction generateHierarchicalTree(\n  sortBy,\n  hierarchicalSeparator,\n  hierarchicalRootPath,\n  hierarchicalShowParentLevel,\n  currentRefinement\n) {\n  return function generateTree(\n    hierarchicalTree,\n    hierarchicalFacetResult,\n    currentHierarchicalLevel\n  ) {\n    var parent = hierarchicalTree;\n\n    if (currentHierarchicalLevel > 0) {\n      var level = 0;\n\n      parent = hierarchicalTree;\n\n      while (level < currentHierarchicalLevel) {\n        /**\n         * @type {object[]]} hierarchical data\n         */\n        var data = parent && Array.isArray(parent.data) ? parent.data : [];\n        parent = find(data, function(subtree) {\n          return subtree.isRefined;\n        });\n        level++;\n      }\n    }\n\n    // we found a refined parent, let's add current level data under it\n    if (parent) {\n      // filter values in case an object has multiple categories:\n      //   {\n      //     categories: {\n      //       level0: ['beers', 'bières'],\n      //       level1: ['beers > IPA', 'bières > Belges']\n      //     }\n      //   }\n      //\n      // If parent refinement is `beers`, then we do not want to have `bières > Belges`\n      // showing up\n\n      var picked = Object.keys(hierarchicalFacetResult.data)\n        .map(function(facetValue) {\n          return [facetValue, hierarchicalFacetResult.data[facetValue]];\n        })\n        .filter(function(tuple) {\n          var facetValue = tuple[0];\n          return onlyMatchingTree(\n            facetValue,\n            parent.path || hierarchicalRootPath,\n            currentRefinement,\n            hierarchicalSeparator,\n            hierarchicalRootPath,\n            hierarchicalShowParentLevel\n          );\n        });\n\n      parent.data = orderBy(\n        picked.map(function(tuple) {\n          var facetValue = tuple[0];\n          var facetCount = tuple[1];\n\n          return format(\n            facetCount,\n            facetValue,\n            hierarchicalSeparator,\n            currentRefinement,\n            hierarchicalFacetResult.exhaustive\n          );\n        }),\n        sortBy[0],\n        sortBy[1]\n      );\n    }\n\n    return hierarchicalTree;\n  };\n}\n\nfunction onlyMatchingTree(\n  facetValue,\n  parentPath,\n  currentRefinement,\n  hierarchicalSeparator,\n  hierarchicalRootPath,\n  hierarchicalShowParentLevel\n) {\n  // we want the facetValue is a child of hierarchicalRootPath\n  if (\n    hierarchicalRootPath &&\n    (facetValue.indexOf(hierarchicalRootPath) !== 0 ||\n      hierarchicalRootPath === facetValue)\n  ) {\n    return false;\n  }\n\n  // we always want root levels (only when there is no prefix path)\n  return (\n    (!hierarchicalRootPath &&\n      facetValue.indexOf(hierarchicalSeparator) === -1) ||\n    // if there is a rootPath, being root level mean 1 level under rootPath\n    (hierarchicalRootPath &&\n      facetValue.split(hierarchicalSeparator).length -\n        hierarchicalRootPath.split(hierarchicalSeparator).length ===\n        1) ||\n    // if current refinement is a root level and current facetValue is a root level,\n    // keep the facetValue\n    (facetValue.indexOf(hierarchicalSeparator) === -1 &&\n      currentRefinement.indexOf(hierarchicalSeparator) === -1) ||\n    // currentRefinement is a child of the facet value\n    currentRefinement.indexOf(facetValue) === 0 ||\n    // facetValue is a child of the current parent, add it\n    (facetValue.indexOf(parentPath + hierarchicalSeparator) === 0 &&\n      (hierarchicalShowParentLevel ||\n        facetValue.indexOf(currentRefinement) === 0))\n  );\n}\n\nfunction format(\n  facetCount,\n  facetValue,\n  hierarchicalSeparator,\n  currentRefinement,\n  exhaustive\n) {\n  var parts = facetValue.split(hierarchicalSeparator);\n  return {\n    name: parts[parts.length - 1].trim(),\n    path: facetValue,\n    count: facetCount,\n    isRefined:\n      currentRefinement === facetValue ||\n      currentRefinement.indexOf(facetValue + hierarchicalSeparator) === 0,\n    exhaustive: exhaustive,\n    data: null\n  };\n}\n"]},"metadata":{},"sourceType":"script"}