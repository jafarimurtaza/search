{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport { objectHasKeys } from '../core/utils';\nimport createConnector from '../core/createConnector';\nimport { getResults, getCurrentRefinementValue, getIndexId, refineValue, cleanUpValue } from '../core/indexUtils';\n/**\n * The GeoSearch connector provides the logic to build a widget that will display the results on a map.\n * It also provides a way to search for results based on their position. The connector provides function to manage the search experience (search on map interaction).\n * @name connectGeoSearch\n * @kind connector\n * @requirements Note that the GeoSearch connector uses the [geosearch](https://www.algolia.com/doc/guides/searching/geo-search) capabilities of Algolia.\n * Your hits **must** have a `_geoloc` attribute in order to be passed to the rendering function. Currently, the feature is not compatible with multiple values in the `_geoloc` attribute\n * (e.g. a restaurant with multiple locations). In that case you can duplicate your records and use the [distinct](https://www.algolia.com/doc/guides/ranking/distinct) feature of Algolia to only retrieve unique results.\n * @propType {{ northEast: { lat: number, lng: number }, southWest: { lat: number, lng: number } }} [defaultRefinement] - Default search state of the widget containing the bounds for the map\n * @providedPropType {function({ northEast: { lat: number, lng: number }, southWest: { lat: number, lng: number } })} refine - a function to toggle the refinement\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {array.<object>} hits - the records that matched the search\n * @providedPropType {boolean} isRefinedWithMap - true if the current refinement is set with the map bounds\n * @providedPropType {{ northEast: { lat: number, lng: number }, southWest: { lat: number, lng: number } }} [currentRefinement] - the refinement currently applied\n * @providedPropType {{ lat: number, lng: number }} [position] - the position of the search\n */\n// To control the map with an external widget the other widget\n// **must** write the value in the attribute `aroundLatLng`\n\nvar getBoundingBoxId = function getBoundingBoxId() {\n  return 'boundingBox';\n};\n\nvar getAroundLatLngId = function getAroundLatLngId() {\n  return 'aroundLatLng';\n};\n\nvar getConfigureAroundLatLngId = function getConfigureAroundLatLngId() {\n  return 'configure.aroundLatLng';\n};\n\nvar currentRefinementToString = function currentRefinementToString(currentRefinement) {\n  return [currentRefinement.northEast.lat, currentRefinement.northEast.lng, currentRefinement.southWest.lat, currentRefinement.southWest.lng].join();\n};\n\nvar stringToCurrentRefinement = function stringToCurrentRefinement(value) {\n  var values = value.split(',');\n  return {\n    northEast: {\n      lat: parseFloat(values[0]),\n      lng: parseFloat(values[1])\n    },\n    southWest: {\n      lat: parseFloat(values[2]),\n      lng: parseFloat(values[3])\n    }\n  };\n};\n\nvar latLngRegExp = /^(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)$/;\n\nvar stringToPosition = function stringToPosition(value) {\n  var pattern = value.match(latLngRegExp);\n  return {\n    lat: parseFloat(pattern[1]),\n    lng: parseFloat(pattern[2])\n  };\n};\n\nvar getCurrentRefinement = function getCurrentRefinement(props, searchState, context) {\n  var refinement = getCurrentRefinementValue(props, searchState, context, getBoundingBoxId(), {});\n\n  if (!objectHasKeys(refinement)) {\n    return;\n  } // eslint-disable-next-line consistent-return\n\n\n  return {\n    northEast: {\n      lat: parseFloat(refinement.northEast.lat),\n      lng: parseFloat(refinement.northEast.lng)\n    },\n    southWest: {\n      lat: parseFloat(refinement.southWest.lat),\n      lng: parseFloat(refinement.southWest.lng)\n    }\n  };\n};\n\nvar getCurrentPosition = function getCurrentPosition(props, searchState, context) {\n  var defaultRefinement = props.defaultRefinement,\n      propsWithoutDefaultRefinement = _objectWithoutProperties(props, [\"defaultRefinement\"]);\n\n  var aroundLatLng = getCurrentRefinementValue(propsWithoutDefaultRefinement, searchState, context, getAroundLatLngId());\n\n  if (!aroundLatLng) {\n    // Fallback on `configure.aroundLatLng`\n    var configureAroundLatLng = getCurrentRefinementValue(propsWithoutDefaultRefinement, searchState, context, getConfigureAroundLatLngId());\n    return configureAroundLatLng && stringToPosition(configureAroundLatLng);\n  }\n\n  return aroundLatLng;\n};\n\nvar _refine = function refine(searchState, nextValue, context) {\n  var resetPage = true;\n\n  var nextRefinement = _defineProperty({}, getBoundingBoxId(), nextValue);\n\n  return refineValue(searchState, nextRefinement, context, resetPage);\n};\n\nexport default createConnector({\n  displayName: 'AlgoliaGeoSearch',\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var context = {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    };\n    var results = getResults(searchResults, context); // We read it from both because the SearchParameters & the searchState are not always\n    // in sync. When we set the refinement the searchState is used but when we clear the refinement\n    // the SearchParameters is used. In the first case when we render, the results are not there\n    // so we can't find the value from the results. The most up to date value is the searchState.\n    // But when we clear the refinement the searchState is immediately cleared even when the items\n    // retrieved are still the one from the previous query with the bounding box. It leads to some\n    // issue with the position of the map. We should rely on 1 source of truth or at least always\n    // be sync.\n\n    var currentRefinementFromSearchState = getCurrentRefinement(props, searchState, context);\n    var currentRefinementFromSearchParameters = results && results._state.insideBoundingBox && stringToCurrentRefinement(results._state.insideBoundingBox) || undefined;\n    var currentPositionFromSearchState = getCurrentPosition(props, searchState, context);\n    var currentPositionFromSearchParameters = results && results._state.aroundLatLng && stringToPosition(results._state.aroundLatLng) || undefined;\n    var currentRefinement = currentRefinementFromSearchState || currentRefinementFromSearchParameters;\n    var position = currentPositionFromSearchState || currentPositionFromSearchParameters;\n    return {\n      hits: !results ? [] : results.hits.filter(function (_) {\n        return Boolean(_._geoloc);\n      }),\n      isRefinedWithMap: Boolean(currentRefinement),\n      currentRefinement: currentRefinement,\n      position: position\n    };\n  },\n  refine: function refine(props, searchState, nextValue) {\n    return _refine(searchState, nextValue, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  getSearchParameters: function getSearchParameters(searchParameters, props, searchState) {\n    var currentRefinement = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n\n    if (!currentRefinement) {\n      return searchParameters;\n    }\n\n    return searchParameters.setQueryParameter('insideBoundingBox', currentRefinementToString(currentRefinement));\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return cleanUpValue(searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }, getBoundingBoxId());\n  },\n  getMetadata: function getMetadata(props, searchState) {\n    var items = [];\n    var id = getBoundingBoxId();\n    var context = {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    };\n    var index = getIndexId(context);\n    var nextRefinement = {};\n    var currentRefinement = getCurrentRefinement(props, searchState, context);\n\n    if (currentRefinement) {\n      items.push({\n        label: \"\".concat(id, \": \").concat(currentRefinementToString(currentRefinement)),\n        value: function value(nextState) {\n          return _refine(nextState, nextRefinement, context);\n        },\n        currentRefinement: currentRefinement\n      });\n    }\n\n    return {\n      id: id,\n      index: index,\n      items: items\n    };\n  },\n  shouldComponentUpdate: function shouldComponentUpdate() {\n    return true;\n  }\n});","map":{"version":3,"sources":["C:/Users/Murtaza Jafari/Desktop/product-search/product/searcbox/node_modules/react-instantsearch-core/dist/es/connectors/connectGeoSearch.js"],"names":["_defineProperty","_objectWithoutProperties","objectHasKeys","createConnector","getResults","getCurrentRefinementValue","getIndexId","refineValue","cleanUpValue","getBoundingBoxId","getAroundLatLngId","getConfigureAroundLatLngId","currentRefinementToString","currentRefinement","northEast","lat","lng","southWest","join","stringToCurrentRefinement","value","values","split","parseFloat","latLngRegExp","stringToPosition","pattern","match","getCurrentRefinement","props","searchState","context","refinement","getCurrentPosition","defaultRefinement","propsWithoutDefaultRefinement","aroundLatLng","configureAroundLatLng","_refine","refine","nextValue","resetPage","nextRefinement","displayName","getProvidedProps","searchResults","ais","contextValue","multiIndexContext","indexContextValue","results","currentRefinementFromSearchState","currentRefinementFromSearchParameters","_state","insideBoundingBox","undefined","currentPositionFromSearchState","currentPositionFromSearchParameters","position","hits","filter","_","Boolean","_geoloc","isRefinedWithMap","getSearchParameters","searchParameters","setQueryParameter","cleanUp","getMetadata","items","id","index","push","label","concat","nextState","shouldComponentUpdate"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport { objectHasKeys } from '../core/utils';\nimport createConnector from '../core/createConnector';\nimport { getResults, getCurrentRefinementValue, getIndexId, refineValue, cleanUpValue } from '../core/indexUtils';\n/**\n * The GeoSearch connector provides the logic to build a widget that will display the results on a map.\n * It also provides a way to search for results based on their position. The connector provides function to manage the search experience (search on map interaction).\n * @name connectGeoSearch\n * @kind connector\n * @requirements Note that the GeoSearch connector uses the [geosearch](https://www.algolia.com/doc/guides/searching/geo-search) capabilities of Algolia.\n * Your hits **must** have a `_geoloc` attribute in order to be passed to the rendering function. Currently, the feature is not compatible with multiple values in the `_geoloc` attribute\n * (e.g. a restaurant with multiple locations). In that case you can duplicate your records and use the [distinct](https://www.algolia.com/doc/guides/ranking/distinct) feature of Algolia to only retrieve unique results.\n * @propType {{ northEast: { lat: number, lng: number }, southWest: { lat: number, lng: number } }} [defaultRefinement] - Default search state of the widget containing the bounds for the map\n * @providedPropType {function({ northEast: { lat: number, lng: number }, southWest: { lat: number, lng: number } })} refine - a function to toggle the refinement\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {array.<object>} hits - the records that matched the search\n * @providedPropType {boolean} isRefinedWithMap - true if the current refinement is set with the map bounds\n * @providedPropType {{ northEast: { lat: number, lng: number }, southWest: { lat: number, lng: number } }} [currentRefinement] - the refinement currently applied\n * @providedPropType {{ lat: number, lng: number }} [position] - the position of the search\n */\n// To control the map with an external widget the other widget\n// **must** write the value in the attribute `aroundLatLng`\n\nvar getBoundingBoxId = function getBoundingBoxId() {\n  return 'boundingBox';\n};\n\nvar getAroundLatLngId = function getAroundLatLngId() {\n  return 'aroundLatLng';\n};\n\nvar getConfigureAroundLatLngId = function getConfigureAroundLatLngId() {\n  return 'configure.aroundLatLng';\n};\n\nvar currentRefinementToString = function currentRefinementToString(currentRefinement) {\n  return [currentRefinement.northEast.lat, currentRefinement.northEast.lng, currentRefinement.southWest.lat, currentRefinement.southWest.lng].join();\n};\n\nvar stringToCurrentRefinement = function stringToCurrentRefinement(value) {\n  var values = value.split(',');\n  return {\n    northEast: {\n      lat: parseFloat(values[0]),\n      lng: parseFloat(values[1])\n    },\n    southWest: {\n      lat: parseFloat(values[2]),\n      lng: parseFloat(values[3])\n    }\n  };\n};\n\nvar latLngRegExp = /^(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)$/;\n\nvar stringToPosition = function stringToPosition(value) {\n  var pattern = value.match(latLngRegExp);\n  return {\n    lat: parseFloat(pattern[1]),\n    lng: parseFloat(pattern[2])\n  };\n};\n\nvar getCurrentRefinement = function getCurrentRefinement(props, searchState, context) {\n  var refinement = getCurrentRefinementValue(props, searchState, context, getBoundingBoxId(), {});\n\n  if (!objectHasKeys(refinement)) {\n    return;\n  } // eslint-disable-next-line consistent-return\n\n\n  return {\n    northEast: {\n      lat: parseFloat(refinement.northEast.lat),\n      lng: parseFloat(refinement.northEast.lng)\n    },\n    southWest: {\n      lat: parseFloat(refinement.southWest.lat),\n      lng: parseFloat(refinement.southWest.lng)\n    }\n  };\n};\n\nvar getCurrentPosition = function getCurrentPosition(props, searchState, context) {\n  var defaultRefinement = props.defaultRefinement,\n      propsWithoutDefaultRefinement = _objectWithoutProperties(props, [\"defaultRefinement\"]);\n\n  var aroundLatLng = getCurrentRefinementValue(propsWithoutDefaultRefinement, searchState, context, getAroundLatLngId());\n\n  if (!aroundLatLng) {\n    // Fallback on `configure.aroundLatLng`\n    var configureAroundLatLng = getCurrentRefinementValue(propsWithoutDefaultRefinement, searchState, context, getConfigureAroundLatLngId());\n    return configureAroundLatLng && stringToPosition(configureAroundLatLng);\n  }\n\n  return aroundLatLng;\n};\n\nvar _refine = function refine(searchState, nextValue, context) {\n  var resetPage = true;\n\n  var nextRefinement = _defineProperty({}, getBoundingBoxId(), nextValue);\n\n  return refineValue(searchState, nextRefinement, context, resetPage);\n};\n\nexport default createConnector({\n  displayName: 'AlgoliaGeoSearch',\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var context = {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    };\n    var results = getResults(searchResults, context); // We read it from both because the SearchParameters & the searchState are not always\n    // in sync. When we set the refinement the searchState is used but when we clear the refinement\n    // the SearchParameters is used. In the first case when we render, the results are not there\n    // so we can't find the value from the results. The most up to date value is the searchState.\n    // But when we clear the refinement the searchState is immediately cleared even when the items\n    // retrieved are still the one from the previous query with the bounding box. It leads to some\n    // issue with the position of the map. We should rely on 1 source of truth or at least always\n    // be sync.\n\n    var currentRefinementFromSearchState = getCurrentRefinement(props, searchState, context);\n    var currentRefinementFromSearchParameters = results && results._state.insideBoundingBox && stringToCurrentRefinement(results._state.insideBoundingBox) || undefined;\n    var currentPositionFromSearchState = getCurrentPosition(props, searchState, context);\n    var currentPositionFromSearchParameters = results && results._state.aroundLatLng && stringToPosition(results._state.aroundLatLng) || undefined;\n    var currentRefinement = currentRefinementFromSearchState || currentRefinementFromSearchParameters;\n    var position = currentPositionFromSearchState || currentPositionFromSearchParameters;\n    return {\n      hits: !results ? [] : results.hits.filter(function (_) {\n        return Boolean(_._geoloc);\n      }),\n      isRefinedWithMap: Boolean(currentRefinement),\n      currentRefinement: currentRefinement,\n      position: position\n    };\n  },\n  refine: function refine(props, searchState, nextValue) {\n    return _refine(searchState, nextValue, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  getSearchParameters: function getSearchParameters(searchParameters, props, searchState) {\n    var currentRefinement = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n\n    if (!currentRefinement) {\n      return searchParameters;\n    }\n\n    return searchParameters.setQueryParameter('insideBoundingBox', currentRefinementToString(currentRefinement));\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return cleanUpValue(searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }, getBoundingBoxId());\n  },\n  getMetadata: function getMetadata(props, searchState) {\n    var items = [];\n    var id = getBoundingBoxId();\n    var context = {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    };\n    var index = getIndexId(context);\n    var nextRefinement = {};\n    var currentRefinement = getCurrentRefinement(props, searchState, context);\n\n    if (currentRefinement) {\n      items.push({\n        label: \"\".concat(id, \": \").concat(currentRefinementToString(currentRefinement)),\n        value: function value(nextState) {\n          return _refine(nextState, nextRefinement, context);\n        },\n        currentRefinement: currentRefinement\n      });\n    }\n\n    return {\n      id: id,\n      index: index,\n      items: items\n    };\n  },\n  shouldComponentUpdate: function shouldComponentUpdate() {\n    return true;\n  }\n});"]},"metadata":{},"sourceType":"module"}