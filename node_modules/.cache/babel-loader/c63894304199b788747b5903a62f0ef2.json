{"ast":null,"code":"'use strict';\n/**\n * Functions to manipulate refinement lists\n *\n * The RefinementList is not formally defined through a prototype but is based\n * on a specific structure.\n *\n * @module SearchParameters.refinementList\n *\n * @typedef {string[]} SearchParameters.refinementList.Refinements\n * @typedef {Object.<string, SearchParameters.refinementList.Refinements>} SearchParameters.refinementList.RefinementList\n */\n\nvar defaultsPure = require('../functions/defaultsPure');\n\nvar omit = require('../functions/omit');\n\nvar objectHasKeys = require('../functions/objectHasKeys');\n\nvar lib = {\n  /**\n   * Adds a refinement to a RefinementList\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} value the value of the refinement, if the value is not a string it will be converted\n   * @return {RefinementList} a new and updated refinement list\n   */\n  addRefinement: function addRefinement(refinementList, attribute, value) {\n    if (lib.isRefined(refinementList, attribute, value)) {\n      return refinementList;\n    }\n\n    var valueAsString = '' + value;\n    var facetRefinement = !refinementList[attribute] ? [valueAsString] : refinementList[attribute].concat(valueAsString);\n    var mod = {};\n    mod[attribute] = facetRefinement;\n    return defaultsPure({}, mod, refinementList);\n  },\n\n  /**\n   * Removes refinement(s) for an attribute:\n   *  - if the value is specified removes the refinement for the value on the attribute\n   *  - if no value is specified removes all the refinements for this attribute\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} [value] the value of the refinement\n   * @return {RefinementList} a new and updated refinement lst\n   */\n  removeRefinement: function removeRefinement(refinementList, attribute, value) {\n    if (value === undefined) {\n      // we use the \"filter\" form of clearRefinement, since it leaves empty values as-is\n      // the form with a string will remove the attribute completely\n      return lib.clearRefinement(refinementList, function (v, f) {\n        return attribute === f;\n      });\n    }\n\n    var valueAsString = '' + value;\n    return lib.clearRefinement(refinementList, function (v, f) {\n      return attribute === f && valueAsString === v;\n    });\n  },\n\n  /**\n   * Toggles the refinement value for an attribute.\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} value the value of the refinement\n   * @return {RefinementList} a new and updated list\n   */\n  toggleRefinement: function toggleRefinement(refinementList, attribute, value) {\n    if (value === undefined) throw new Error('toggleRefinement should be used with a value');\n\n    if (lib.isRefined(refinementList, attribute, value)) {\n      return lib.removeRefinement(refinementList, attribute, value);\n    }\n\n    return lib.addRefinement(refinementList, attribute, value);\n  },\n\n  /**\n   * Clear all or parts of a RefinementList. Depending on the arguments, three\n   * kinds of behavior can happen:\n   *  - if no attribute is provided: clears the whole list\n   *  - if an attribute is provided as a string: clears the list for the specific attribute\n   *  - if an attribute is provided as a function: discards the elements for which the function returns true\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} [attribute] the attribute or function to discard\n   * @param {string} [refinementType] optional parameter to give more context to the attribute function\n   * @return {RefinementList} a new and updated refinement list\n   */\n  clearRefinement: function clearRefinement(refinementList, attribute, refinementType) {\n    if (attribute === undefined) {\n      if (!objectHasKeys(refinementList)) {\n        return refinementList;\n      }\n\n      return {};\n    } else if (typeof attribute === 'string') {\n      return omit(refinementList, [attribute]);\n    } else if (typeof attribute === 'function') {\n      var hasChanged = false;\n      var newRefinementList = Object.keys(refinementList).reduce(function (memo, key) {\n        var values = refinementList[key] || [];\n        var facetList = values.filter(function (value) {\n          return !attribute(value, key, refinementType);\n        });\n\n        if (facetList.length !== values.length) {\n          hasChanged = true;\n        }\n\n        memo[key] = facetList;\n        return memo;\n      }, {});\n      if (hasChanged) return newRefinementList;\n      return refinementList;\n    }\n  },\n\n  /**\n   * Test if the refinement value is used for the attribute. If no refinement value\n   * is provided, test if the refinementList contains any refinement for the\n   * given attribute.\n   * @param {RefinementList} refinementList the list of refinement\n   * @param {string} attribute name of the attribute\n   * @param {string} [refinementValue] value of the filter/refinement\n   * @return {boolean}\n   */\n  isRefined: function isRefined(refinementList, attribute, refinementValue) {\n    var containsRefinements = !!refinementList[attribute] && refinementList[attribute].length > 0;\n\n    if (refinementValue === undefined || !containsRefinements) {\n      return containsRefinements;\n    }\n\n    var refinementValueAsString = '' + refinementValue;\n    return refinementList[attribute].indexOf(refinementValueAsString) !== -1;\n  }\n};\nmodule.exports = lib;","map":{"version":3,"sources":["C:/Users/Murtaza Jafari/Desktop/product-search/product/searcbox/node_modules/algoliasearch-helper/src/SearchParameters/RefinementList.js"],"names":["defaultsPure","require","omit","objectHasKeys","lib","addRefinement","refinementList","attribute","value","isRefined","valueAsString","facetRefinement","concat","mod","removeRefinement","undefined","clearRefinement","v","f","toggleRefinement","Error","refinementType","hasChanged","newRefinementList","Object","keys","reduce","memo","key","values","facetList","filter","length","refinementValue","containsRefinements","refinementValueAsString","indexOf","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Functions to manipulate refinement lists\n *\n * The RefinementList is not formally defined through a prototype but is based\n * on a specific structure.\n *\n * @module SearchParameters.refinementList\n *\n * @typedef {string[]} SearchParameters.refinementList.Refinements\n * @typedef {Object.<string, SearchParameters.refinementList.Refinements>} SearchParameters.refinementList.RefinementList\n */\n\nvar defaultsPure = require('../functions/defaultsPure');\nvar omit = require('../functions/omit');\nvar objectHasKeys = require('../functions/objectHasKeys');\n\nvar lib = {\n  /**\n   * Adds a refinement to a RefinementList\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} value the value of the refinement, if the value is not a string it will be converted\n   * @return {RefinementList} a new and updated refinement list\n   */\n  addRefinement: function addRefinement(refinementList, attribute, value) {\n    if (lib.isRefined(refinementList, attribute, value)) {\n      return refinementList;\n    }\n\n    var valueAsString = '' + value;\n\n    var facetRefinement = !refinementList[attribute] ?\n      [valueAsString] :\n      refinementList[attribute].concat(valueAsString);\n\n    var mod = {};\n\n    mod[attribute] = facetRefinement;\n\n    return defaultsPure({}, mod, refinementList);\n  },\n  /**\n   * Removes refinement(s) for an attribute:\n   *  - if the value is specified removes the refinement for the value on the attribute\n   *  - if no value is specified removes all the refinements for this attribute\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} [value] the value of the refinement\n   * @return {RefinementList} a new and updated refinement lst\n   */\n  removeRefinement: function removeRefinement(refinementList, attribute, value) {\n    if (value === undefined) {\n      // we use the \"filter\" form of clearRefinement, since it leaves empty values as-is\n      // the form with a string will remove the attribute completely\n      return lib.clearRefinement(refinementList, function(v, f) {\n        return attribute === f;\n      });\n    }\n\n    var valueAsString = '' + value;\n\n    return lib.clearRefinement(refinementList, function(v, f) {\n      return attribute === f && valueAsString === v;\n    });\n  },\n  /**\n   * Toggles the refinement value for an attribute.\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} value the value of the refinement\n   * @return {RefinementList} a new and updated list\n   */\n  toggleRefinement: function toggleRefinement(refinementList, attribute, value) {\n    if (value === undefined) throw new Error('toggleRefinement should be used with a value');\n\n    if (lib.isRefined(refinementList, attribute, value)) {\n      return lib.removeRefinement(refinementList, attribute, value);\n    }\n\n    return lib.addRefinement(refinementList, attribute, value);\n  },\n  /**\n   * Clear all or parts of a RefinementList. Depending on the arguments, three\n   * kinds of behavior can happen:\n   *  - if no attribute is provided: clears the whole list\n   *  - if an attribute is provided as a string: clears the list for the specific attribute\n   *  - if an attribute is provided as a function: discards the elements for which the function returns true\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} [attribute] the attribute or function to discard\n   * @param {string} [refinementType] optional parameter to give more context to the attribute function\n   * @return {RefinementList} a new and updated refinement list\n   */\n  clearRefinement: function clearRefinement(refinementList, attribute, refinementType) {\n    if (attribute === undefined) {\n      if (!objectHasKeys(refinementList)) {\n        return refinementList;\n      }\n      return {};\n    } else if (typeof attribute === 'string') {\n      return omit(refinementList, [attribute]);\n    } else if (typeof attribute === 'function') {\n      var hasChanged = false;\n\n      var newRefinementList = Object.keys(refinementList).reduce(function(memo, key) {\n        var values = refinementList[key] || [];\n        var facetList = values.filter(function(value) {\n          return !attribute(value, key, refinementType);\n        });\n\n        if (facetList.length !== values.length) {\n          hasChanged = true;\n        }\n        memo[key] = facetList;\n\n        return memo;\n      }, {});\n\n      if (hasChanged) return newRefinementList;\n      return refinementList;\n    }\n  },\n  /**\n   * Test if the refinement value is used for the attribute. If no refinement value\n   * is provided, test if the refinementList contains any refinement for the\n   * given attribute.\n   * @param {RefinementList} refinementList the list of refinement\n   * @param {string} attribute name of the attribute\n   * @param {string} [refinementValue] value of the filter/refinement\n   * @return {boolean}\n   */\n  isRefined: function isRefined(refinementList, attribute, refinementValue) {\n    var containsRefinements = !!refinementList[attribute] &&\n      refinementList[attribute].length > 0;\n\n    if (refinementValue === undefined || !containsRefinements) {\n      return containsRefinements;\n    }\n\n    var refinementValueAsString = '' + refinementValue;\n\n    return refinementList[attribute].indexOf(refinementValueAsString) !== -1;\n  }\n};\n\nmodule.exports = lib;\n"]},"metadata":{},"sourceType":"script"}