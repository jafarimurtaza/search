{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport PropTypes from 'prop-types';\nimport createConnector from '../core/createConnector';\nimport { cleanUpValue, getIndexId, refineValue, getCurrentRefinementValue, getResults } from '../core/indexUtils';\nvar namespace = 'refinementList';\n\nfunction getId(props) {\n  return props.attribute;\n}\n\nfunction getCurrentRefinement(props, searchState, context) {\n  var currentRefinement = getCurrentRefinementValue(props, searchState, context, \"\".concat(namespace, \".\").concat(getId(props)), []);\n\n  if (typeof currentRefinement !== 'string') {\n    return currentRefinement;\n  }\n\n  if (currentRefinement) {\n    return [currentRefinement];\n  }\n\n  return [];\n}\n\nfunction getValue(name, props, searchState, context) {\n  var currentRefinement = getCurrentRefinement(props, searchState, context);\n  var isAnewValue = currentRefinement.indexOf(name) === -1;\n  var nextRefinement = isAnewValue ? currentRefinement.concat([name]) // cannot use .push(), it mutates\n  : currentRefinement.filter(function (selectedValue) {\n    return selectedValue !== name;\n  }); // cannot use .splice(), it mutates\n\n  return nextRefinement;\n}\n\nfunction getLimit(_ref) {\n  var showMore = _ref.showMore,\n      limit = _ref.limit,\n      showMoreLimit = _ref.showMoreLimit;\n  return showMore ? showMoreLimit : limit;\n}\n\nfunction _refine(props, searchState, nextRefinement, context) {\n  var id = getId(props); // Setting the value to an empty string ensures that it is persisted in\n  // the URL as an empty value.\n  // This is necessary in the case where `defaultRefinement` contains one\n  // item and we try to deselect it. `nextSelected` would be an empty array,\n  // which would not be persisted to the URL.\n  // {foo: ['bar']} => \"foo[0]=bar\"\n  // {foo: []} => \"\"\n\n  var nextValue = _defineProperty({}, id, nextRefinement.length > 0 ? nextRefinement : '');\n\n  var resetPage = true;\n  return refineValue(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction _cleanUp(props, searchState, context) {\n  return cleanUpValue(searchState, context, \"\".concat(namespace, \".\").concat(getId(props)));\n}\n/**\n * connectRefinementList connector provides the logic to build a widget that will\n * give the user the ability to choose multiple values for a specific facet.\n * @name connectRefinementList\n * @kind connector\n * @requirements The attribute passed to the `attribute` prop must be present in \"attributes for faceting\"\n * on the Algolia dashboard or configured as `attributesForFaceting` via a set settings call to the Algolia API.\n * @propType {string} attribute - the name of the attribute in the record\n * @propType {boolean} [searchable=false] - allow search inside values\n * @propType {string} [operator=or] - How to apply the refinements. Possible values: 'or' or 'and'.\n * @propType {boolean} [showMore=false] - true if the component should display a button that will expand the number of items\n * @propType {number} [limit=10] - the minimum number of displayed items\n * @propType {number} [showMoreLimit=20] - the maximun number of displayed items. Only used when showMore is set to `true`\n * @propType {string[]} defaultRefinement - the values of the items selected by default. The searchState of this widget takes the form of a list of `string`s, which correspond to the values of all selected refinements. However, when there are no refinements selected, the value of the searchState is an empty string.\n * @propType {function} [transformItems] - Function to modify the items being displayed, e.g. for filtering or sorting them. Takes an items as parameter and expects it back in return.\n * @providedPropType {function} refine - a function to toggle a refinement\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string[]} currentRefinement - the refinement currently applied\n * @providedPropType {array.<{count: number, isRefined: boolean, label: string, value: string}>} items - the list of items the RefinementList can display.\n * @providedPropType {function} searchForItems - a function to toggle a search inside items values\n * @providedPropType {boolean} isFromSearch - a boolean that says if the `items` props contains facet values from the global search or from the search inside items.\n * @providedPropType {boolean} canRefine - a boolean that says whether you can refine\n */\n\n\nvar sortBy = ['isRefined', 'count:desc', 'name:asc'];\nexport default createConnector({\n  displayName: 'AlgoliaRefinementList',\n  propTypes: {\n    id: PropTypes.string,\n    attribute: PropTypes.string.isRequired,\n    operator: PropTypes.oneOf(['and', 'or']),\n    showMore: PropTypes.bool,\n    limit: PropTypes.number,\n    showMoreLimit: PropTypes.number,\n    defaultRefinement: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])),\n    searchable: PropTypes.bool,\n    transformItems: PropTypes.func\n  },\n  defaultProps: {\n    operator: 'or',\n    showMore: false,\n    limit: 10,\n    showMoreLimit: 20\n  },\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults, metadata, searchForFacetValuesResults) {\n    var attribute = props.attribute,\n        searchable = props.searchable,\n        indexContextValue = props.indexContextValue;\n    var results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    var canRefine = Boolean(results) && Boolean(results.getFacetByName(attribute));\n    var isFromSearch = Boolean(searchForFacetValuesResults && searchForFacetValuesResults[attribute] && searchForFacetValuesResults.query !== ''); // Search For Facet Values is not available with derived helper (used for multi index search)\n\n    if (searchable && indexContextValue) {\n      throw new Error('react-instantsearch: searching in *List is not available when used inside a' + ' multi index context');\n    }\n\n    if (!canRefine) {\n      return {\n        items: [],\n        currentRefinement: getCurrentRefinement(props, searchState, {\n          ais: props.contextValue,\n          multiIndexContext: props.indexContextValue\n        }),\n        canRefine: canRefine,\n        isFromSearch: isFromSearch,\n        searchable: searchable\n      };\n    }\n\n    var items = isFromSearch ? searchForFacetValuesResults[attribute].map(function (v) {\n      return {\n        label: v.value,\n        value: getValue(v.value, props, searchState, {\n          ais: props.contextValue,\n          multiIndexContext: props.indexContextValue\n        }),\n        _highlightResult: {\n          label: {\n            value: v.highlighted\n          }\n        },\n        count: v.count,\n        isRefined: v.isRefined\n      };\n    }) : results.getFacetValues(attribute, {\n      sortBy: sortBy\n    }).map(function (v) {\n      return {\n        label: v.name,\n        value: getValue(v.name, props, searchState, {\n          ais: props.contextValue,\n          multiIndexContext: props.indexContextValue\n        }),\n        count: v.count,\n        isRefined: v.isRefined\n      };\n    });\n    var transformedItems = props.transformItems ? props.transformItems(items) : items;\n    return {\n      items: transformedItems.slice(0, getLimit(props)),\n      currentRefinement: getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      }),\n      isFromSearch: isFromSearch,\n      searchable: searchable,\n      canRefine: transformedItems.length > 0\n    };\n  },\n  refine: function refine(props, searchState, nextRefinement) {\n    return _refine(props, searchState, nextRefinement, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  searchForFacetValues: function searchForFacetValues(props, searchState, nextRefinement) {\n    return {\n      facetName: props.attribute,\n      query: nextRefinement,\n      maxFacetHits: getLimit(props)\n    };\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return _cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  getSearchParameters: function getSearchParameters(searchParameters, props, searchState) {\n    var attribute = props.attribute,\n        operator = props.operator;\n    var addKey = operator === 'and' ? 'addFacet' : 'addDisjunctiveFacet';\n    var addRefinementKey = \"\".concat(addKey, \"Refinement\");\n    searchParameters = searchParameters.setQueryParameters({\n      maxValuesPerFacet: Math.max(searchParameters.maxValuesPerFacet || 0, getLimit(props))\n    });\n    searchParameters = searchParameters[addKey](attribute);\n    return getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }).reduce(function (res, val) {\n      return res[addRefinementKey](attribute, val);\n    }, searchParameters);\n  },\n  getMetadata: function getMetadata(props, searchState) {\n    var id = getId(props);\n    var context = {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    };\n    return {\n      id: id,\n      index: getIndexId(context),\n      items: getCurrentRefinement(props, searchState, context).length > 0 ? [{\n        attribute: props.attribute,\n        label: \"\".concat(props.attribute, \": \"),\n        currentRefinement: getCurrentRefinement(props, searchState, context),\n        value: function value(nextState) {\n          return _refine(props, nextState, [], context);\n        },\n        items: getCurrentRefinement(props, searchState, context).map(function (item) {\n          return {\n            label: \"\".concat(item),\n            value: function value(nextState) {\n              var nextSelectedItems = getCurrentRefinement(props, nextState, context).filter(function (other) {\n                return other !== item;\n              });\n              return _refine(props, searchState, nextSelectedItems, context);\n            }\n          };\n        })\n      }] : []\n    };\n  }\n});","map":{"version":3,"sources":["C:/Users/Murtaza Jafari/Desktop/product-search/product/searcbox/node_modules/react-instantsearch-core/dist/es/connectors/connectRefinementList.js"],"names":["_defineProperty","PropTypes","createConnector","cleanUpValue","getIndexId","refineValue","getCurrentRefinementValue","getResults","namespace","getId","props","attribute","getCurrentRefinement","searchState","context","currentRefinement","concat","getValue","name","isAnewValue","indexOf","nextRefinement","filter","selectedValue","getLimit","_ref","showMore","limit","showMoreLimit","_refine","id","nextValue","length","resetPage","_cleanUp","sortBy","displayName","propTypes","string","isRequired","operator","oneOf","bool","number","defaultRefinement","arrayOf","oneOfType","searchable","transformItems","func","defaultProps","getProvidedProps","searchResults","metadata","searchForFacetValuesResults","indexContextValue","results","ais","contextValue","multiIndexContext","canRefine","Boolean","getFacetByName","isFromSearch","query","Error","items","map","v","label","value","_highlightResult","highlighted","count","isRefined","getFacetValues","transformedItems","slice","refine","searchForFacetValues","facetName","maxFacetHits","cleanUp","getSearchParameters","searchParameters","addKey","addRefinementKey","setQueryParameters","maxValuesPerFacet","Math","max","reduce","res","val","getMetadata","index","nextState","item","nextSelectedItems","other"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport PropTypes from 'prop-types';\nimport createConnector from '../core/createConnector';\nimport { cleanUpValue, getIndexId, refineValue, getCurrentRefinementValue, getResults } from '../core/indexUtils';\nvar namespace = 'refinementList';\n\nfunction getId(props) {\n  return props.attribute;\n}\n\nfunction getCurrentRefinement(props, searchState, context) {\n  var currentRefinement = getCurrentRefinementValue(props, searchState, context, \"\".concat(namespace, \".\").concat(getId(props)), []);\n\n  if (typeof currentRefinement !== 'string') {\n    return currentRefinement;\n  }\n\n  if (currentRefinement) {\n    return [currentRefinement];\n  }\n\n  return [];\n}\n\nfunction getValue(name, props, searchState, context) {\n  var currentRefinement = getCurrentRefinement(props, searchState, context);\n  var isAnewValue = currentRefinement.indexOf(name) === -1;\n  var nextRefinement = isAnewValue ? currentRefinement.concat([name]) // cannot use .push(), it mutates\n  : currentRefinement.filter(function (selectedValue) {\n    return selectedValue !== name;\n  }); // cannot use .splice(), it mutates\n\n  return nextRefinement;\n}\n\nfunction getLimit(_ref) {\n  var showMore = _ref.showMore,\n      limit = _ref.limit,\n      showMoreLimit = _ref.showMoreLimit;\n  return showMore ? showMoreLimit : limit;\n}\n\nfunction _refine(props, searchState, nextRefinement, context) {\n  var id = getId(props); // Setting the value to an empty string ensures that it is persisted in\n  // the URL as an empty value.\n  // This is necessary in the case where `defaultRefinement` contains one\n  // item and we try to deselect it. `nextSelected` would be an empty array,\n  // which would not be persisted to the URL.\n  // {foo: ['bar']} => \"foo[0]=bar\"\n  // {foo: []} => \"\"\n\n  var nextValue = _defineProperty({}, id, nextRefinement.length > 0 ? nextRefinement : '');\n\n  var resetPage = true;\n  return refineValue(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction _cleanUp(props, searchState, context) {\n  return cleanUpValue(searchState, context, \"\".concat(namespace, \".\").concat(getId(props)));\n}\n/**\n * connectRefinementList connector provides the logic to build a widget that will\n * give the user the ability to choose multiple values for a specific facet.\n * @name connectRefinementList\n * @kind connector\n * @requirements The attribute passed to the `attribute` prop must be present in \"attributes for faceting\"\n * on the Algolia dashboard or configured as `attributesForFaceting` via a set settings call to the Algolia API.\n * @propType {string} attribute - the name of the attribute in the record\n * @propType {boolean} [searchable=false] - allow search inside values\n * @propType {string} [operator=or] - How to apply the refinements. Possible values: 'or' or 'and'.\n * @propType {boolean} [showMore=false] - true if the component should display a button that will expand the number of items\n * @propType {number} [limit=10] - the minimum number of displayed items\n * @propType {number} [showMoreLimit=20] - the maximun number of displayed items. Only used when showMore is set to `true`\n * @propType {string[]} defaultRefinement - the values of the items selected by default. The searchState of this widget takes the form of a list of `string`s, which correspond to the values of all selected refinements. However, when there are no refinements selected, the value of the searchState is an empty string.\n * @propType {function} [transformItems] - Function to modify the items being displayed, e.g. for filtering or sorting them. Takes an items as parameter and expects it back in return.\n * @providedPropType {function} refine - a function to toggle a refinement\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string[]} currentRefinement - the refinement currently applied\n * @providedPropType {array.<{count: number, isRefined: boolean, label: string, value: string}>} items - the list of items the RefinementList can display.\n * @providedPropType {function} searchForItems - a function to toggle a search inside items values\n * @providedPropType {boolean} isFromSearch - a boolean that says if the `items` props contains facet values from the global search or from the search inside items.\n * @providedPropType {boolean} canRefine - a boolean that says whether you can refine\n */\n\n\nvar sortBy = ['isRefined', 'count:desc', 'name:asc'];\nexport default createConnector({\n  displayName: 'AlgoliaRefinementList',\n  propTypes: {\n    id: PropTypes.string,\n    attribute: PropTypes.string.isRequired,\n    operator: PropTypes.oneOf(['and', 'or']),\n    showMore: PropTypes.bool,\n    limit: PropTypes.number,\n    showMoreLimit: PropTypes.number,\n    defaultRefinement: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])),\n    searchable: PropTypes.bool,\n    transformItems: PropTypes.func\n  },\n  defaultProps: {\n    operator: 'or',\n    showMore: false,\n    limit: 10,\n    showMoreLimit: 20\n  },\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults, metadata, searchForFacetValuesResults) {\n    var attribute = props.attribute,\n        searchable = props.searchable,\n        indexContextValue = props.indexContextValue;\n    var results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    var canRefine = Boolean(results) && Boolean(results.getFacetByName(attribute));\n    var isFromSearch = Boolean(searchForFacetValuesResults && searchForFacetValuesResults[attribute] && searchForFacetValuesResults.query !== ''); // Search For Facet Values is not available with derived helper (used for multi index search)\n\n    if (searchable && indexContextValue) {\n      throw new Error('react-instantsearch: searching in *List is not available when used inside a' + ' multi index context');\n    }\n\n    if (!canRefine) {\n      return {\n        items: [],\n        currentRefinement: getCurrentRefinement(props, searchState, {\n          ais: props.contextValue,\n          multiIndexContext: props.indexContextValue\n        }),\n        canRefine: canRefine,\n        isFromSearch: isFromSearch,\n        searchable: searchable\n      };\n    }\n\n    var items = isFromSearch ? searchForFacetValuesResults[attribute].map(function (v) {\n      return {\n        label: v.value,\n        value: getValue(v.value, props, searchState, {\n          ais: props.contextValue,\n          multiIndexContext: props.indexContextValue\n        }),\n        _highlightResult: {\n          label: {\n            value: v.highlighted\n          }\n        },\n        count: v.count,\n        isRefined: v.isRefined\n      };\n    }) : results.getFacetValues(attribute, {\n      sortBy: sortBy\n    }).map(function (v) {\n      return {\n        label: v.name,\n        value: getValue(v.name, props, searchState, {\n          ais: props.contextValue,\n          multiIndexContext: props.indexContextValue\n        }),\n        count: v.count,\n        isRefined: v.isRefined\n      };\n    });\n    var transformedItems = props.transformItems ? props.transformItems(items) : items;\n    return {\n      items: transformedItems.slice(0, getLimit(props)),\n      currentRefinement: getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      }),\n      isFromSearch: isFromSearch,\n      searchable: searchable,\n      canRefine: transformedItems.length > 0\n    };\n  },\n  refine: function refine(props, searchState, nextRefinement) {\n    return _refine(props, searchState, nextRefinement, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  searchForFacetValues: function searchForFacetValues(props, searchState, nextRefinement) {\n    return {\n      facetName: props.attribute,\n      query: nextRefinement,\n      maxFacetHits: getLimit(props)\n    };\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return _cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  getSearchParameters: function getSearchParameters(searchParameters, props, searchState) {\n    var attribute = props.attribute,\n        operator = props.operator;\n    var addKey = operator === 'and' ? 'addFacet' : 'addDisjunctiveFacet';\n    var addRefinementKey = \"\".concat(addKey, \"Refinement\");\n    searchParameters = searchParameters.setQueryParameters({\n      maxValuesPerFacet: Math.max(searchParameters.maxValuesPerFacet || 0, getLimit(props))\n    });\n    searchParameters = searchParameters[addKey](attribute);\n    return getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }).reduce(function (res, val) {\n      return res[addRefinementKey](attribute, val);\n    }, searchParameters);\n  },\n  getMetadata: function getMetadata(props, searchState) {\n    var id = getId(props);\n    var context = {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    };\n    return {\n      id: id,\n      index: getIndexId(context),\n      items: getCurrentRefinement(props, searchState, context).length > 0 ? [{\n        attribute: props.attribute,\n        label: \"\".concat(props.attribute, \": \"),\n        currentRefinement: getCurrentRefinement(props, searchState, context),\n        value: function value(nextState) {\n          return _refine(props, nextState, [], context);\n        },\n        items: getCurrentRefinement(props, searchState, context).map(function (item) {\n          return {\n            label: \"\".concat(item),\n            value: function value(nextState) {\n              var nextSelectedItems = getCurrentRefinement(props, nextState, context).filter(function (other) {\n                return other !== item;\n              });\n              return _refine(props, searchState, nextSelectedItems, context);\n            }\n          };\n        })\n      }] : []\n    };\n  }\n});"]},"metadata":{},"sourceType":"module"}